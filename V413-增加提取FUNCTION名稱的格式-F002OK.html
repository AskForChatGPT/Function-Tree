<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>暗黑節點編輯器</title>
  <style>
    body {
      background: #1e1e1e;
      color: #ffffff;
      font-family: 'Arial', sans-serif;
      margin: 0;
      overflow: hidden;
      user-select: none;
    }

    #canvas-container {
      position: fixed;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      cursor: grab;
    }

    #canvas-container.panning {
      cursor: grabbing;
    }

    #canvas-container.connecting,
    #canvas-container.selecting {
      cursor: crosshair;
    }

    #transform-container {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      will-change: transform;
    }

    #nodes-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform-origin: 0 0;
    }

    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(45, 45, 45, 0.3);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
    }

    #left-panel {
      position: fixed;
      left: 0;
      top: 261px;
      width: 300px;
      height: calc(100vh - 70px);
      background: rgba(30, 30, 30, 0.9);
      border-right: 1px solid #444;
      padding: 10px;
      overflow-y: auto;
      z-index: 100;
    }

    #node-list-container h3 {
      color: #fff;
      margin-bottom: 15px;
      padding-bottom: 5px;
      border-bottom: 1px solid #555;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    .node {
      position: absolute;
      background: rgba(45, 45, 45, 0.85);
      border: 1px solid rgba(68, 68, 68, 0.5);
      border-radius: 8px;
      width: 200px;
      padding: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      z-index: 10;
      transform-origin: 0 0;
      transform: none !important;
      backdrop-filter: blur(2px);
    }

    .node.transparent {
      background: rgba(30, 30, 30, 0.5);
      backdrop-filter: blur(4px);
    }

    .node.selected {
      border: 2px solid #4a90e2;
      box-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
    }

    .node.highlight {
      box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0.7);
      transition: box-shadow 0.3s;
    }

    .node.highlight-same-name {
      box-shadow: 0 0 15px 5px rgba(255, 204, 0, 0.7);
      transition: box-shadow 0.3s;
    }

    .node.highlight-found {
      box-shadow: 0 0 15px 5px rgba(0, 255, 255, 0.7) !important;
      transition: box-shadow 0.3s;
    }

    .node-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      gap: 5px;
      z-index: 15;
    }

    .node-title,
    .item-text,
    .paragraph-input,
    .N-input {
      background: rgba(58, 58, 58, 0.8) !important;
      color: #ffffff !important;
      border: 1px solid rgba(85, 85, 85, 0.5) !important;
    }

    .node-title {
      order: 4;
      flex-grow: 1;
      padding: 5px;
      font-size: 14px;
      border-radius: 4px;
      margin: 0 5px;
      width: calc(100% - 50px);
    }

    .node-title:focus,
    .item-text:focus,
    .paragraph-input:focus {
      outline: none;
      border-color: #777 !important;
    }

    .input-port,
    .output-port {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      cursor: pointer;
      position: relative;
      z-index: 30;
      border: 2px solid #333;
    }

    .input-port {
      background: #4CAF50;
      margin-right: 5px;
      order: 1;
    }

    .output-port {
      background: #FF5722;
      margin-left: 5px;
    }

    .input-port:hover,
    .output-port:hover {
      background: #ffffff;
      transform: scale(1.2);
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
    }

    .item {
      display: flex;
      align-items: center;
      margin: 5px 0;
      background: #333;
      padding: 5px;
      border-radius: 4px;
    }

    .item-text {
      flex-grow: 1;
      padding: 5px;
      font-size: 12px;
      border-radius: 4px;
      width: calc(100% - 50px);
    }

    .paragraph-input,
    .N-input {
      width: 95%;
      min-height: 60px;
      padding: 5px;
      margin-bottom: 10px;
      border-radius: 4px;
      resize: vertical;
    }

    .node-list-item {
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(45, 45, 45, 0.7);
      border-radius: 4px;
      opacity: 0.6;
    }

    .node-list-name {
      color: #fff;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .node-list-description {
      width: 100%;
      min-height: 60px;
      background: #3a3a3a;
      border: 1px solid #555;
      color: #fff;
      padding: 5px;
      border-radius: 4px;
      resize: vertical;
      opacity: 0.8;
      transition: opacity 0.8s ease;
    }

    .node-list-description:focus {
      opacity: 1;
    }

    .add-node-btn,
    .toolbar-btn,
    .add-item-btn,
    .generate-btn,
    .update-btn,
    .hide-children-btn {
      background: #555;
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
    }

    .add-node-btn {
      margin-right: 5px;
      padding: 2px 8px;
    }

    .add-node-btn:hover,
    .toolbar-btn:hover,
    .add-item-btn:hover,
    .generate-btn:hover,
    .update-btn:hover {
      background: #777;
    }

    .toolbar-btn,
    #node-search-btn {
      background: rgba(85, 85, 85, 0.3) !important;
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
      padding: 8px 12px;
      margin: 0 5px;
      transition: background 0.2s;
    }

    .toolbar-btn:hover,
    #node-search-btn:hover {
      background: rgba(119, 119, 119, 0.3) !important;
    }

    .add-item-btn {
      padding: 5px 10px;
      width: 80px;
      margin-right: 5px;
      text-align: center;
    }

    .generate-btn {
      padding: 5px 10px;
      width: 80px;
      margin-left: 5px;
      display: inline-block;
      text-align: center;
    }

    .update-btn {
      margin-left: 5px;
      padding: 5px 10px;
      font-size: 12px;
    }

    .delete-node-btn {
      background: #ff4444;
      border: none;
      color: #fff;
      cursor: pointer;
      margin-left: 5px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      order: 5;
    }

    .delete-node-btn:hover {
      background: #ff6666;
    }

    .copy-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255, 165, 0, 0.7);
      border: none;
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      z-index: 1;
    }

    .copy-btn:hover {
      background: rgba(255, 165, 0, 0.9);
    }

    .jump-to-btn {
      position: relative;
      width: 15px;
      height: 15px;
      margin-right: 5px;
      background: #ffcc00;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
      flex-shrink: 0;
      order: 3;
    }

    .jump-to-btn::after {
      content: attr(data-count);
      position: absolute;
      top: -8px;
      right: -8px;
      background: #ff4444;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .jump-to-btn:hover {
      opacity: 1;
      transform: scale(1.2);
    }

    .jump-to-btn.hidden {
      display: none;
    }

    .paragraph-btn {
      width: 100%;
      background: #4a4a4a;
      border: 1px solid #555;
      color: #aaa;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 4px;
      cursor: pointer;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .paragraph-popup-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2147483647;
      pointer-events: none;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .paragraph-popup-container>div:first-child {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      pointer-events: auto;
    }

    .paragraph-popup {
      position: relative;
      background: rgba(45, 45, 45, 0.7);
      border: 1px solid #555;
      border-radius: 4px;
      padding: 10px;
      max-width: 80vw;
      max-height: 80vh;
      overflow: auto;
      z-index: 2147483647;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      white-space: pre-wrap;
      font-family: monospace;
      pointer-events: auto;
      display: none;
      backdrop-filter: blur(2px);
    }

    .paragraph-popup::after {
      content: "按 X 清空內容";
      position: absolute;
      bottom: 5px;
      right: 5px;
      font-size: 10px;
      color: #888;
    }

    .selection-box {
      position: absolute;
      background: rgba(100, 100, 255, 0.1);
      border: 1px solid rgba(100, 100, 255, 0.8);
      pointer-events: none;
      z-index: 5;
    }

    .update-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .update-dialog-content {
      background-color: #333;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .update-dialog textarea {
      width: 100%;
      height: 200px;
      background-color: #444;
      color: #fff;
      border: 1px solid #555;
      padding: 10px;
      margin-bottom: 15px;
      font-family: inherit;
      resize: vertical;
    }

    .update-dialog-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .update-dialog-buttons button {
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .update-dialog-confirm {
      background-color: #4CAF50;
      color: white;
    }

    .update-dialog-cancel {
      background-color: #f44336;
      color: white;
    }

    .buttons-container {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      width: 100%;
    }

    #file-input,
    #import-selected-input {
      display: none;
      opacity: 0.3;
    }



    /* 基礎節點顏色 - 0.38透明度 */
    .node.color-0 {
      background: rgba(45, 45, 45, 0.85) !important;
    }

    /* 深灰 */
    .node.color-1 {
      background: rgba(100, 181, 246, 0.38) !important;
    }

    /* 明藍 */
    .node.color-2 {
      background: rgba(129, 199, 132, 0.38) !important;
    }

    /* 鮮綠 */
    .node.color-3 {
      background: rgba(255, 138, 101, 0.38) !important;
    }

    /* 橙紅 */
    .node.color-4 {
      background: rgba(186, 104, 200, 0.38) !important;
    }

    /* 紫羅蘭 */
    .node.color-5 {
      background: rgba(255, 213, 79, 0.38) !important;
    }

    /* 金黃 */
    .node.color-6 {
      background: rgba(77, 208, 225, 0.38) !important;
    }

    /* 青藍 */
    .node.color-7 {
      background: rgba(240, 98, 146, 0.38) !important;
    }

    /* 玫紅 */
    .node.color-8 {
      background: rgba(79, 195, 247, 0.38) !important;
    }

    /* 天藍 */
    .node.color-9 {
      background: rgba(174, 213, 129, 0.38) !important;
    }

    /* 黃綠 */
    .node.color-10 {
      background: rgba(255, 112, 67, 0.38) !important;
    }

    /* 橙黃 */
    .node.color-11 {
      background: rgba(229, 115, 115, 0.38) !important;
    }

    /* 珊瑚紅 */
    .node.color-12 {
      background: rgba(149, 117, 205, 0.38) !important;
    }

    /* 薰衣草 */
    .node.color-13 {
      background: rgba(255, 152, 0, 0.38) !important;
    }

    /* 橘色 */
    .node.color-14 {
      background: rgba(126, 87, 194, 0.38) !important;
    }

    /* 深紫 */
    .node.color-15 {
      background: rgba(38, 166, 154, 0.38) !important;
    }

    /* 藍綠 */

    /* 透明狀態 - 0.5透明度 */
    /* 乳白半透明風格 - 0.4透明度 */
    .node.transparent.color-0 {
      background: rgba(240, 240, 240, 0.4) !important;
    }

    /* 珍珠白 */
    .node.transparent.color-1 {
      background: rgba(220, 235, 255, 0.4) !important;
    }

    /* 乳白藍 */
    .node.transparent.color-2 {
      background: rgba(230, 250, 230, 0.4) !important;
    }

    /* 乳白綠 */
    .node.transparent.color-3 {
      background: rgba(255, 230, 220, 0.4) !important;
    }

    /* 乳白橙 */
    .node.transparent.color-4 {
      background: rgba(245, 230, 250, 0.4) !important;
    }

    /* 乳白紫 */
    .node.transparent.color-5 {
      background: rgba(255, 245, 210, 0.4) !important;
    }

    /* 乳白黃 */
    .node.transparent.color-6 {
      background: rgba(220, 245, 250, 0.4) !important;
    }

    /* 乳白青 */
    .node.transparent.color-7 {
      background: rgba(255, 220, 235, 0.4) !important;
    }

    /* 乳白粉 */
    .node.transparent.color-8 {
      background: rgba(230, 240, 255, 0.4) !important;
    }

    /* 乳白天藍 */
    .node.transparent.color-9 {
      background: rgba(240, 245, 220, 0.4) !important;
    }

    /* 乳白薄荷 */
    .node.transparent.color-10 {
      background: rgba(255, 235, 230, 0.4) !important;
    }

    /* 乳白珊瑚 */
    .node.transparent.color-11 {
      background: rgba(255, 230, 230, 0.4) !important;
    }

    /* 乳白玫瑰 */
    .node.transparent.color-12 {
      background: rgba(245, 240, 250, 0.4) !important;
    }

    /* 乳白薰衣草 */
    .node.transparent.color-13 {
      background: rgba(255, 240, 220, 0.4) !important;
    }

    /* 乳白杏色 */
    .node.transparent.color-14 {
      background: rgba(235, 230, 255, 0.4) !important;
    }

    /* 乳白淡紫 */
    .node.transparent.color-15 {
      background: rgba(220, 245, 240, 0.4) !important;
    }

    /* 乳白海沫 */

    /* 彈窗狀態 - 0.3透明度 */
    .paragraph-popup.color-0 {
      background: rgba(216, 216, 216, 0.4) !important;
      /* 珍珠白 */
    }

    .paragraph-popup.color-1 {
      background: rgba(112, 177, 255, 0.4) !important;
      /* 乳白藍 */
    }

    .paragraph-popup.color-2 {
      background: rgba(164, 229, 164, 0.4) !important;
      /* 乳白綠 */
    }

    .paragraph-popup.color-3 {
      background: rgba(255, 190, 138, 0.4) !important;
      /* 乳白橙 */
    }

    .paragraph-popup.color-4 {
      background: rgba(190, 138, 216, 0.4) !important;
      /* 乳白紫 */
    }

    .paragraph-popup.color-5 {
      background: rgba(255, 229, 138, 0.4) !important;
      /* 乳白黃 */
    }

    .paragraph-popup.color-6 {
      background: rgba(164, 229, 229, 0.4) !important;
      /* 乳白青 */
    }

    .paragraph-popup.color-7 {
      background: rgba(229, 138, 164, 0.4) !important;
      /* 乳白粉 */
    }

    .paragraph-popup.color-8 {
      background: rgba(151, 190, 255, 0.4) !important;
      /* 乳白天藍 */
    }

    .paragraph-popup.color-9 {
      background: rgba(164, 216, 164, 0.4) !important;
      /* 乳白薄荷 */
    }

    .paragraph-popup.color-10 {
      background: rgba(255, 190, 190, 0.4) !important;
      /* 乳白珊瑚 */
    }

    .paragraph-popup.color-11 {
      background: rgba(255, 164, 190, 0.4) !important;
      /* 乳白玫瑰 */
    }

    .paragraph-popup.color-12 {
      background: rgba(216, 190, 242, 0.4) !important;
      /* 乳白薰衣草 */
    }

    .paragraph-popup.color-13 {
      background: rgba(255, 216, 164, 0.4) !important;
      /* 乳白杏色 */
    }

    .paragraph-popup.color-14 {
      background: rgba(203, 190, 255, 0.4) !important;
      /* 乳白淡紫 */
    }


    .node.collapsed {
      width: auto !important;
      min-width: 150px;
      padding: 5px !important;
      overflow: visible !important;
    }

    .node.collapsed .node-header {
      margin-bottom: 0 !important;
    }

    .node.collapsed .collapsible {
      display: none !important;
    }

    .node.collapsed .output-port {
      margin-left: 5px !important;
      order: 5 !important;
    }

    #connection-canvas {
      z-index: 0 !important;
    }

    .node.collapsed .header-port {
      position: absolute;
      right: 25px;
      top: 50%;
      transform: translateY(-50%);
      width: 12px;
      height: 12px;
      background: #FF5722;
      border-radius: 50%;
      border: 2px solid #333;
      z-index: 30;
    }

    .collapse-btn {
      order: 2;
      background: #555;
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 20px;
      margin-right: 5px;
    }

    #node-search-input {
      background: rgba(58, 58, 58, 0.3) !important;
      color: #ffffff !important;
      border: 1px solid rgba(85, 85, 85, 0.3) !important;
      border-radius: 4px;
      padding: 5px;
      font-family: inherit;
      margin-left: 10px;
    }

    #node-search-input:focus {
      outline: none;
      border-color: rgba(119, 119, 119, 0.3) !important;
    }

    .drag-handle {
      cursor: move;
      padding: 0 5px;
      user-select: none;
      opacity: 0.5;
      transition: opacity 0.2s;
      font-family: Arial, sans-serif;
      display: inline-block;
    }

    .drag-handle:hover {
      opacity: 1;
    }

    .item.dragging {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      background: rgba(255, 255, 255, 0.1);
    }

    .item-placeholder {
      background: rgba(255, 255, 255, 0.1);
      border: 1px dashed #888;
      margin: 5px 0;
      border-radius: 4px;
      transition: all 0.2s;
    }

    #minimap-container {
      position: fixed;
      left: 0;
      top: 60px;
      width: 300px;
      height: 200px;
      background: rgba(30, 30, 30, 0.7);
      border-bottom: 1px solid #444;
      z-index: 100;
      overflow: hidden;
    }

    #minimap {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    #viewport-indicator {
      position: absolute;
      border: 2px solid rgba(255, 255, 255, 0.8);
      background: rgba(255, 255, 255, 0.1);
      pointer-events: none;
      z-index: 101;
      transform-origin: center center;
      box-sizing: border-box;
    }

    .node.group-node {
      border: 2px dashed #666;
      background-color: rgba(200, 200, 200, 0.2);
    }

    .node.group-node .group-node-info {
      padding: 5px;
      text-align: center;
      color: #666;
      font-size: 0.9em;
    }

    .node.group-node .ungroup-btn {
      background-color: #ffcccc;
      border: 1px solid #ff9999;
      margin-left: 5px;
      font-size: 12px;
      padding: 2px 5px;
    }

    .node.group-node .ungroup-btn:hover {
      background-color: #ff9999;
    }

    .variable-analysis-container {
      margin-top: 10px;
      border: 1px solid #444;
      border-radius: 4px;
      overflow: hidden;
      background-color: #2d2d2d;
    }

    .variable-analysis-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 10px;
      background-color: #1e1e1e;
      cursor: pointer;
      border-bottom: 1px solid #444;
      color: #e0e0e0;
      user-select: none;
    }

    .variable-analysis-title {
      flex-grow: 1;
    }

    .variable-analysis-content {
      padding: 8px;
      display: none;
      max-height: 150px;
      overflow-y: auto;
      background-color: #2d2d2d;
    }

    .variable-analysis-container.expanded .variable-analysis-content {
      display: block;
    }

    .variable-btn {
      display: block;
      width: calc(100% - 12px);
      padding: 6px 8px;
      margin: 4px 0;
      text-align: left;
      border: 1px solid #444;
      border-radius: 3px;
      background-color: #3d3d3d;
      color: #e0e0e0;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.85em;
    }

    .variable-btn:hover {
      background-color: #4a4a4a;
    }

    .variable-btn[data-active="true"] {
      background-color: #1a5276;
      color: white;
      border-color: #154360;
    }

    .no-variables-message {
      color: #999;
      font-style: italic;
      text-align: center;
      padding: 8px 0;
      font-size: 0.85em;
    }

    .toggle-variable-analysis-btn {
      border: none;
      background: none;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 1.2em;
      padding: 0 5px;
      min-width: 20px;
      text-align: center;
    }

    .dark-mode .variable-analysis-container {
      border-color: #555;
      background-color: #333;
    }

    .dark-mode .variable-analysis-header {
      background-color: #252525;
      border-bottom-color: #555;
    }

    .dark-mode .variable-btn {
      background-color: #3a3a3a;
      border-color: #555;
    }

    .dark-mode .variable-btn:hover {
      background-color: #4a4a4a;
    }

    .variable-highlight {
      color: #4a90e2;
      font-weight: bold;
      background-color: rgba(74, 144, 226, 0.1);
      padding: 0 2px;
      border-radius: 3px;
    }

    #load-html-btn {
      margin-left: 10px;
    }

    @keyframes pulse {
      0% {
        background-color: rgba(0, 255, 255, 0.3);
      }

      50% {
        background-color: rgba(0, 255, 255, 0.8);
      }

      100% {
        background-color: transparent;
      }
    }

    .title-highlight {
      animation: pulse 1s ease-in-out;
    }

    .toolbar-select {
      margin-left: 5px;
      padding: 5px 25px 5px 10px;
      /* 增加右側空間給箭頭 */
      border-radius: 4px;
      border: 1px solid #4a5568;
      /* 暗色邊框 */
      background-color: #2d3748;
      /* 暗色背景 */
      color: #e2e8f0;
      /* 淺色文字 */
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .toolbar-checkbox {
      margin-left: 10px;
      vertical-align: middle;
    }

    .frame-node {
      border: 2px dashed #4a90e2 !important;
      background: rgba(74, 144, 226, 0.1) !important;
      min-width: 300px;
      min-height: 200px;
      z-index: 1 !important;
      /* 確保框架使用低z-index */
      position: relative;
      display: flex;
      flex-direction: column;
      pointer-events: none;
      /* 允許事件穿透 */
    }

    .frame-node .frame-header,
    .frame-node .frame-content,
    .frame-node .frame-footer {
      pointer-events: auto;
      /* 只有框架的特定部分可以接收事件 */
    }

    .frame-header {
      padding: 10px;
      flex-shrink: 0;
      position: relative;
    }

    .frame-content {
      flex: 1;
      padding: 10px;
      border-top: 1px solid #444;
      overflow-y: auto;
    }

    .frame-footer {
      padding: 10px;
      border-top: 1px solid #444;
      flex-shrink: 0;
      position: relative;
    }

    .add-note-btn {
      background: #555;
      border: none;
      color: #fff;
      padding: 8px;
      width: 100%;
      border-radius: 4px;
      cursor: pointer;
    }

    .add-note-btn:hover {
      background: #777;
    }

    .frame-note {
      background: rgba(255, 255, 255, 0.05);
      padding: 8px;
      margin: 5px 0;
      border-radius: 4px;
      border: 1px solid #444;
    }

    .delete-node-btn {
      position: absolute;
      right: 10px;
      top: 10px;
      background: rgba(255, 68, 68, 0.6);
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      /* 確保關閉按鈕在框架上方 */
    }

    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #4a90e2;
      right: -5px;
      bottom: -5px;
      cursor: nwse-resize;
      z-index: 1;
      /* 低於節點的z-index */
      border-radius: 2px;
    }

    .frame-content {
      flex: 1;
      padding: 10px;
      border-top: 1px solid #444;
      overflow-y: auto;
    }

    .node.highlight-missing {
      box-shadow: 0 0 15px 5px rgba(255, 0, 0, 0.7) !important;
      transition: box-shadow 0.3s;
    }

    .item.highlight-missing {
      background: rgba(255, 0, 0, 0.3) !important;
      border: 1px solid rgba(255, 0, 0, 0.5) !important;
    }
  </style>
</head>

<body>

  <div id="toolbar">
    <button class="toolbar-btn" id="save-btn">保存</button>
    <button class="toolbar-btn" id="load-btn">載入</button>
    <button class="toolbar-btn" id="select-jump-nodes-btn">選取所有jump-to-btn</button>
    <button class="toolbar-btn" id="rearrange-all-btn">重新排列所有NODE</button>
    <button class="toolbar-btn" id="export-selected-btn">滙出框選NODE</button>
    <button class="toolbar-btn" id="import-selected-btn">滙入框選NODE</button>
    <input type="file" id="file-input" accept=".json">
    <button class="toolbar-btn" id="load-html-btn">載入檔案更新NODE</button>
    <button class="toolbar-btn" id="check-missing-nodes-btn">檢查未加入的NODE名稱</button>
    <input type="file" id="html-file-input" accept=".html,.htm" style="display:none">
    <input type="file" id="import-selected-input" accept=".json," style="display:none">
    <button class="toolbar-btn" id="add-frame-btn">區域描述框</button>


    <div id="minimap-container">
      <canvas id="minimap"></canvas>
      <div id="viewport-indicator"></div>
    </div>


    <!-- 新增搜尋框和按鈕 -->
    <input type="text" id="node-search-input" placeholder="搜尋節點名稱" style="margin-left: 10px; padding: 5px;">
    <button class="toolbar-btn" id="node-search-btn">搜尋</button>


    <select id="code-language-selector" class="toolbar-select">
      <option value="html">HTML</option>
      <option value="python">Python</option>
    </select>
    <input type="checkbox" id="exclude-duplicates-checkbox" class="toolbar-checkbox">
    <label for="exclude-duplicates-checkbox">按A不選取重覆</label>
    </select>

  </div>


  <div id="left-panel">
    <div id="node-list-container">
      <h3>可見節點</h3>
      <div id="node-list"></div>
    </div>
  </div>

  <div id="canvas-container">
    <canvas id="connection-canvas"></canvas>
    <div id="canvas-container">
      <div id="transform-container">
        <canvas id="connection-canvas"></canvas>
        <div id="nodes-container"></div>
      </div>
    </div>
  </div>
  <script>
    let generatedNodeCount = 0; // 記錄已生成的完整節點數量

    // 全局變數來控制自動處理
    let autoProcessingInterval = null;
    let autoProcessingStartTime = null;
    let processingQueue = [];
    let processedNodes = new Set();
    let currentPhase = 'initial';

    // 全局變量來存儲加載的函數數據（替代 localStorage）
    let loadedHtmlFunctions = {};
    const container = document.getElementById('canvas-container');
    const nodesContainer = document.getElementById('nodes-container');
    const canvas = document.getElementById('connection-canvas');


    const ctx = canvas.getContext('2d');
    // 全局變量
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    const viewportIndicator = document.getElementById('viewport-indicator');

    // 全局存儲所有彈窗的集合
    const ALL_ACTIVE_POPUPS = new Set();

    // Add to COLOR_CLASSES at the top of your code
    const COLOR_CLASSES = [
      'color-0',  // 深灰 (原基礎色)
      'color-1',  // 淺藍
      'color-2',  // 淺綠
      'color-3',  // 淺橙
      'color-4',  // 淺紫
      'color-5',  // 淺黃
      'color-6',  // 淺青 (新增)
      'color-7',  // 淺粉 (新增)
      'color-8',  // 淡藍 (新增)
      'color-9',  // 米色 (新增)
      'color-10', // 淡綠 (新增)
      'color-11', // 淺紅 (新增)
      'color-12', // 淺灰 (新增)
      'color-13', // 淡紫 (新增)
      'color-14'  // 薄荷綠 (新增)
    ];

    // 添加導出選中節點按鈕事件
    document.getElementById('export-selected-btn').addEventListener('click', exportSelectedNodes);
    document.getElementById('import-selected-btn').addEventListener('click', () => {
      document.getElementById('import-selected-input').click();
    });
    document.getElementById('import-selected-input').addEventListener('change', importSelectedNodes);
    // 新增搜尋功能
    document.getElementById('node-search-btn').addEventListener('click', searchNodesByName);
    document.getElementById('add-frame-btn').addEventListener('click', addNewFrame);
    // 為新按鈕添加事件監聽器（替換原有的）
    document.getElementById('rearrange-all-btn').addEventListener('click', rearrangeAllNodesEnhanced);

    // 添加事件監聽器
    document.getElementById('select-jump-nodes-btn').addEventListener('click', selectAllJumpNodes);


    // 函數名稱黑名單
    const FUNCTION_BLACKLIST = [
      // Array methods

      'HTML',
      'vibrate', 'updateEmojisVisibilityButton', 'updateAttentionAreasButton', 'updatePowerModeButton', 'toDataURL', 'translateX', 'gradient', 'saturate', 'contrast', 'x', 'closeListHandler', 'startSession', 'execCommand', 'clamp', 'closeFunc', 'arrayBuffer',
      'Array',
      'createTreeWalker',
      'cancelScheduledValues',
      'getChannelData',
      'Float32Array',
      'setPeriodicWave',
      'linearRampToValueAtTime',
      'exponentialRampToValueAtTime',
      'prompt',
      'rows',
      'polygon',
      'not',
      'substr',
      'Event',
      'String',
      'File',
      'ClipboardItem',
      'showIOSInstructions',
      'showDataForManualCopy',
      'getContext',
      'getComputedStyle',
      'call',
      'showSaveFilePicker',
      'createWritable',
      'select',

      'group',
      'groupEnd',
      'brightness',
      'add',
      'Set',
      'splice',
      'Time',

      'join',
      'concat',
      'copyWithin',
      'entries',
      'every',
      'fill',
      'filter',
      'find',
      'findIndex',
      'findLast',
      'findLastIndex',
      'flat',
      'flatMap',
      'forEach',
      'from',
      'includes',
      'indexOf',
      'lastIndexOf',
      'map',
      'pop',
      'push',
      'reduce',
      'reduceRight',
      'reverse',
      'shift',
      'slice',
      'some',
      'sort',
      'splice',
      'toLocaleString',
      'toString',
      'unshift',
      'values',
      'DOMParser',
      'parseFromString',
      'isArray',

      // Math functions
      'abs',
      'acos',
      'acosh',
      'asin',
      'asinh',
      'atan',
      'atan2',
      'atanh',
      'cbrt',
      'ceil',
      'clz32',
      'cos',
      'cosh',
      'exp',
      'expm1',
      'floor',
      'fround',
      'hypot',
      'imul',
      'log',
      'log10',
      'log1p',
      'log2',
      'max',
      'min',
      'pow',
      'random',
      'round',
      'sign',
      'sin',
      'sinh',
      'sqrt',
      'tan',
      'tanh',
      'trunc',

      // Timing functions
      'setTimeout',
      'clearTimeout',
      'setInterval',
      'clearInterval',
      'requestAnimationFrame',
      'cancelAnimationFrame',
      'now',
      'performance.now',

      // Canvas 2D API
      'arc',
      'arcTo',
      'beginPath',
      'bezierCurveTo',
      'clearRect',
      'clip',
      'closePath',
      'createImageData',
      'createLinearGradient',
      'createPattern',
      'createRadialGradient',
      'addColorStop',
      'drawFocusIfNeeded',
      'drawImage',
      'ellipse',
      'fill',
      'fillRect',
      'fillText',
      'getImageData',
      'getLineDash',
      'isPointInPath',
      'isPointInStroke',
      'lineTo',
      'measureText',
      'moveTo',
      'putImageData',
      'quadraticCurveTo',
      'rect',
      'restore',
      'rotate',
      'save',
      'scale',
      'setLineDash',
      'setTransform',
      'stroke',
      'strokeRect',
      'strokeText',
      'transform',
      'translate',

      // DOM manipulation
      'addEventListener',
      'append',
      'appendChild',
      'attachShadow',
      'blur',
      'click',
      'cloneNode',
      'closest',
      'contains',
      'createAttribute',
      'createComment',
      'createDocumentFragment',
      'createElement',
      'createElementNS',
      'createEvent',
      'createTextNode',
      'dispatchEvent',
      'focus',
      'getAttribute',
      'getAttributeNS',
      'getBoundingClientRect',
      'getElementsByClassName',
      'getElementsByTagName',
      'getElementsByTagNameNS',
      'getElementById',
      'getSelection',
      'hasAttribute',
      'hasAttributeNS',
      'insertAdjacentElement',
      'insertAdjacentHTML',
      'insertAdjacentText',
      'insertBefore',
      'matches',
      'normalize',
      'prepend',
      'querySelector',
      'querySelectorAll',
      'remove',
      'removeAttribute',
      'removeAttributeNS',
      'removeChild',
      'removeEventListener',
      'replaceChild',
      'replaceWith',
      'requestFullscreen',
      'scroll',
      'scrollIntoView',
      'scrollTo',
      'setAttribute',
      'setAttributeNS',
      'setPointerCapture',
      'toggle',
      'toggleAttribute',

      // String methods
      'charAt',
      'charCodeAt',
      'codePointAt',
      'concat',
      'endsWith',
      'fromCharCode',
      'fromCodePoint',
      'includes',
      'indexOf',
      'lastIndexOf',
      'localeCompare',
      'match',
      'matchAll',
      'normalize',
      'padEnd',
      'padStart',
      'repeat',
      'replace',
      'replaceAll',
      'search',
      'slice',
      'split',
      'startsWith',
      'substring',
      'toLocaleLowerCase',
      'toLocaleUpperCase',
      'toLowerCase',
      'toString',
      'toUpperCase',
      'trim',
      'trimEnd',
      'trimLeft',
      'trimRight',
      'trimStart',
      'valueOf',

      // Object methods
      'assign',
      'create',
      'defineProperties',
      'defineProperty',
      'entries',
      'freeze',
      'fromEntries',
      'getOwnPropertyDescriptor',
      'getOwnPropertyDescriptors',
      'getOwnPropertyNames',
      'getOwnPropertySymbols',
      'getPrototypeOf',
      'hasOwn',
      'hasOwnProperty',
      'is',
      'isExtensible',
      'isFrozen',
      'isPrototypeOf',
      'isSealed',
      'keys',
      'preventExtensions',
      'propertyIsEnumerable',
      'seal',
      'setPrototypeOf',
      'toLocaleString',
      'toString',
      'values',

      // Events
      'preventDefault',
      'stopImmediatePropagation',
      'stopPropagation',

      // Other Web APIs
      'atob',
      'btoa',
      'fetch',
      'FileReader',
      'readAsArrayBuffer',
      'readAsBinaryString',
      'readAsDataURL',
      'readAsText',
      'navigator.clipboard',
      'writeText',
      'readText',
      'URL.createObjectURL',
      'URL.revokeObjectURL',
      'clipboard',
      'createObjectURL',
      'revokeObjectURL',

      'alert',

      'Blob',
      'FormData',
      'Headers',
      'Request',
      'Response',
      'WebSocket',
      'XMLHttpRequest',
      'MutationObserver',
      'IntersectionObserver',
      'ResizeObserver',
      'CustomEvent',

      // Promise/async
      'all',
      'allSettled',
      'any',
      'catch',
      'finally',
      'race',
      'reject',
      'resolve',
      'then',


      '(',
      '$',
      'b',
      'on',

      // JSON
      'parse',
      'stringify',

      // Web Audio API
      'createAnalyser',
      'createBiquadFilter',
      'createBuffer',
      'createBufferSource',
      'createChannelMerger',
      'createChannelSplitter',
      'createConstantSource',
      'createConvolver',
      'createDelay',
      'createDynamicsCompressor',
      'createGain',
      'createIIRFilter',
      'createOscillator',
      'createPanner',
      'createPeriodicWave',
      'createScriptProcessor',
      'createStereoPanner',
      'createWaveShaper',
      'decodeAudioData',
      'setValueAtTime',
      'connect',
      'disconnect',
      'start',
      'stop',
      'suspend',
      'resume',
      'valueToAngle',

      // WebRTC
      'RTCPeerConnection',
      'createOffer',
      'createAnswer',
      'setLocalDescription',
      'setRemoteDescription',
      'addIceCandidate',
      'getUserMedia',
      'sheet_to_json',
      'aoa_to_sheet',
      'sheet_to_csv',

      // WebGL
      'activeTexture',
      'attachShader',
      'bindAttribLocation',
      'bindBuffer',
      'bindFramebuffer',
      'bindRenderbuffer',
      'bindTexture',
      'blendColor',
      'blendEquation',
      'blendEquationSeparate',
      'blendFunc',
      'blendFuncSeparate',
      'bufferData',
      'bufferSubData',
      'checkFramebufferStatus',
      'clear',
      'clearColor',
      'clearDepth',
      'clearStencil',
      'compileShader',
      'compressedTexImage2D',
      'compressedTexSubImage2D',
      'copyTexImage2D',
      'copyTexSubImage2D',
      'createBuffer',
      'createFramebuffer',
      'createProgram',
      'createRenderbuffer',
      'createShader',
      'createTexture',
      'cullFace',
      'deleteBuffer',
      'deleteFramebuffer',
      'deleteProgram',
      'deleteRenderbuffer',
      'deleteShader',
      'deleteTexture',
      'depthFunc',
      'depthMask',
      'depthRange',
      'detachShader',
      'disable',
      'disableVertexAttribArray',
      'drawArrays',
      'drawElements',
      'enable',
      'enableVertexAttribArray',
      'finish',
      'flush',
      'framebufferRenderbuffer',
      'framebufferTexture2D',
      'frontFace',
      'generateMipmap',
      'getActiveAttrib',
      'getActiveUniform',
      'getAttachedShaders',
      'getAttribLocation',
      'getBufferParameter',
      'getContextAttributes',
      'getError',
      'getExtension',
      'getFramebufferAttachmentParameter',
      'getParameter',
      'getProgramInfoLog',
      'getProgramParameter',
      'getRenderbufferParameter',
      'getShaderInfoLog',
      'getShaderParameter',
      'getShaderPrecisionFormat',
      'getShaderSource',
      'getSupportedExtensions',
      'getTexParameter',
      'getUniform',
      'getUniformLocation',
      'getVertexAttrib',
      'getVertexAttribOffset',
      'hint',
      'isBuffer',
      'isContextLost',
      'isEnabled',
      'isFramebuffer',
      'isProgram',
      'isRenderbuffer',
      'isShader',
      'isTexture',
      'lineWidth',
      'linkProgram',
      'pixelStorei',
      'polygonOffset',
      'readPixels',
      'renderbufferStorage',
      'sampleCoverage',
      'scissor',
      'shaderSource',
      'stencilFunc',
      'stencilFuncSeparate',
      'stencilMask',
      'stencilMaskSeparate',
      'stencilOp',
      'stencilOpSeparate',
      'texImage2D',
      'texParameterf',
      'texParameteri',
      'texSubImage2D',
      'uniform1f',
      'uniform1fv',
      'uniform1i',
      'uniform1iv',
      'uniform2f',
      'uniform2fv',
      'uniform2i',
      'uniform2iv',
      'uniform3f',
      'uniform3fv',
      'uniform3i',
      'uniform3iv',
      'uniform4f',
      'uniform4fv',
      'uniform4i',
      'uniform4iv',
      'uniformMatrix2fv',
      'uniformMatrix3fv',
      'uniformMatrix4fv',
      'useProgram',
      'validateProgram',
      'vertexAttrib1f',
      'vertexAttrib1fv',
      'vertexAttrib2f',
      'vertexAttrib2fv',
      'vertexAttrib3f',
      'vertexAttrib3fv',
      'vertexAttrib4f',
      'vertexAttrib4fv',
      'vertexAttribPointer',
      'viewport',

      // Media elements
      'play',
      'pause',
      'load',
      'canPlayType',
      'addTextTrack',
      'captureStream',
      'fastSeek',
      'seekToNextFrame',
      'setSinkId',

      // Web Components
      'customElements.define',
      'customElements.get',
      'customElements.upgrade',
      'customElements.whenDefined',
      'connectedCallback',
      'disconnectedCallback',
      'adoptedCallback',
      'attributeChangedCallback',

      // IndexedDB
      'open',
      'deleteDatabase',
      'createObjectStore',
      'transaction',
      'put',
      'add',
      'get',
      'getAll',
      'getAllKeys',
      'delete',
      'clear',
      'createIndex',
      'count',
      'cursor',

      // Web Storage
      'localStorage',
      'sessionStorage',
      'getItem',
      'setItem',
      'removeItem',
      'clear',
      'key',

      // Web Workers
      'postMessage',
      'terminate',
      'importScripts',

      // Service Workers
      'register',
      'unregister',
      'update',
      'skipWaiting',
      'claim',
      'addEventListener',
      'removeEventListener',
      'dispatchEvent',

      // Web Cryptography
      'crypto.subtle',
      'generateKey',
      'importKey',
      'exportKey',
      'encrypt',
      'decrypt',
      'sign',
      'verify',
      'digest',
      'deriveKey',
      'deriveBits',
      'wrapKey',
      'unwrapKey',

      // Web Animations
      'animate',
      'cancel',
      'finish',
      'pause',
      'play',
      'reverse',
      'updatePlaybackRate',
      'image',
      'Image',



      // Payment Request
      'PaymentRequest',
      'show',
      'abort',
      'canMakePayment',

      // Web Share
      'share',
      'canShare',

      // Web NFC
      'write',
      'scan',

      // Web Bluetooth
      'requestDevice',
      'gatt.connect',
      'getPrimaryService',
      'getCharacteristic',
      'readValue',
      'writeValue',
      'startNotifications',

      // WebUSB
      'requestDevice',
      'open',
      'close',
      'selectConfiguration',
      'claimInterface',
      'releaseInterface',
      'selectAlternateInterface',
      'controlTransferIn',
      'controlTransferOut',
      'clearHalt',
      'transferIn',
      'transferOut',
      'isochronousTransferIn',
      'isochronousTransferOut',
      'reset',

      // WebXR
      'requestSession',
      'endSession',
      'requestReferenceSpace',
      'getViewerPose',
      'getPose',
      'getInputSources',
      'getInputPose',

      // Web MIDI
      'requestMIDIAccess',
      'send',
      'clear',

      // Gamepad
      'getGamepads',
      'vibrationActuator.playEffect',
      'vibrationActuator.reset',

      // Screen Orientation
      'lock',
      'unlock',

      // Device Orientation
      'requestPermission',
      'addEventListener',
      'removeEventListener',

      // Presentation
      'requestSession',
      'reconnect',
      'terminate',

      // Credential Management
      'navigator.credentials',
      'create',
      'get',
      'store',
      'preventSilentAccess',

      // Web Authentication
      'create',
      'get',

      // Web Locks
      'request',
      'query',

      // Web Serial
      'requestPort',
      'open',
      'close',
      'read',
      'write',

      // WebHID
      'requestDevice',
      'open',
      'close',
      'sendReport',
      'receiveReport',
      'sendFeatureReport',
      'receiveFeatureReport',

      // WebCodecs
      'VideoEncoder',
      'VideoDecoder',
      'AudioEncoder',
      'AudioDecoder',
      'ImageDecoder',
      'encode',
      'decode',
      'flush',
      'reset',
      'close',

      // WebTransport
      'createUnidirectionalStream',
      'createBidirectionalStream',
      'datagrams',
      'close',

      // WebGPU
      'requestAdapter',
      'requestDevice',
      'createBuffer',
      'createTexture',
      'createSampler',
      'createBindGroupLayout',
      'createPipelineLayout',
      'createBindGroup',
      'createShaderModule',
      'createComputePipeline',
      'createRenderPipeline',
      'createCommandEncoder',
      'createRenderBundleEncoder',
      'createQuerySet',
      'submit',
      'onSubmittedWorkDone',

      // WebNN
      'createContext',
      'createModel',
      'createCompilation',
      'createExecution',
      'setInput',
      'setOutput',
      'startCompute',
      'wait',

      // WebAssembly
      'instantiate',
      'instantiateStreaming',
      'compile',
      'compileStreaming',
      'validate',
      'Memory',
      'Table',
      'Global',
      'Module',
      'Instance',
      'CompileError',
      'LinkError',
      'RuntimeError',

      // Error types
      'Error',
      'EvalError',
      'RangeError',
      'ReferenceError',
      'SyntaxError',
      'TypeError',
      'URIError',
      'AggregateError',

      // Regular Expressions
      'RegExp',
      'exec',
      'test',
      'match',
      'matchAll',
      'search',
      'replace',
      'replaceAll',
      'split',

      // Date methods
      'Date',
      'now',
      'parse',
      'UTC',
      'getDate',
      'getDay',
      'getFullYear',
      'getHours',
      'getMilliseconds',
      'getMinutes',
      'getMonth',
      'getSeconds',
      'getTime',
      'getTimezoneOffset',
      'getUTCDate',
      'getUTCDay',
      'getUTCFullYear',
      'getUTCHours',
      'getUTCMilliseconds',
      'getUTCMinutes',
      'getUTCMonth',
      'getUTCSeconds',
      'setDate',
      'setFullYear',
      'setHours',
      'setMilliseconds',
      'setMinutes',
      'setMonth',
      'setSeconds',
      'setTime',
      'setUTCDate',
      'setUTCFullYear',
      'setUTCHours',
      'setUTCMilliseconds',
      'setUTCMinutes',
      'setUTCMonth',
      'setUTCSeconds',
      'toDateString',
      'toISOString',
      'toJSON',
      'toLocaleDateString',
      'toLocaleString',
      'toLocaleTimeString',
      'toString',
      'toTimeString',
      'toUTCString',
      'valueOf',

      // Map/Set/WeakMap/WeakSet
      'Map',
      'Set',
      'WeakMap',
      'WeakSet',
      'add',
      'clear',
      'delete',
      'entries',
      'forEach',
      'get',
      'has',
      'keys',
      'set',
      'size',
      'values',

      // TypedArray methods
      'buffer',
      'byteLength',
      'byteOffset',
      'copyWithin',
      'entries',
      'every',
      'fill',
      'filter',
      'find',
      'findIndex',
      'forEach',
      'includes',
      'indexOf',
      'join',
      'keys',
      'lastIndexOf',
      'length',
      'map',
      'reduce',
      'reduceRight',
      'reverse',
      'set',
      'slice',
      'some',
      'sort',
      'subarray',
      'toLocaleString',
      'toString',
      'values',

      // DataView methods
      'buffer',
      'byteLength',
      'byteOffset',
      'getFloat32',
      'getFloat64',
      'getInt8',
      'getInt16',
      'getInt32',
      'getUint8',
      'getUint16',
      'getUint32',
      'setFloat32',
      'setFloat64',
      'setInt8',
      'setInt16',
      'setInt32',
      'setUint8',
      'setUint16',
      'setUint32',

      // Symbol methods
      'Symbol',
      'for',
      'keyFor',
      'toString',
      'valueOf',

      // Proxy/Reflect
      'Proxy',
      'Reflect',
      'apply',
      'construct',
      'defineProperty',
      'deleteProperty',
      'get',
      'getOwnPropertyDescriptor',
      'getPrototypeOf',
      'has',
      'isExtensible',
      'ownKeys',
      'preventExtensions',
      'set',
      'setPrototypeOf',

      // Intl objects
      'Intl',
      'Collator',
      'DateTimeFormat',
      'DisplayNames',
      'ListFormat',
      'Locale',
      'NumberFormat',
      'PluralRules',
      'RelativeTimeFormat',
      'Segmenter',

      // Console methods
      'console.log',
      'console.debug',
      'console.info',
      'console.warn',
      'console.error',
      'console.assert',
      'console.clear',
      'console.count',
      'console.countReset',
      'console.dir',
      'console.dirxml',
      'console.group',
      'console.groupCollapsed',
      'console.groupEnd',
      'console.table',
      'console.time',
      'console.timeLog',
      'console.timeEnd',
      'console.trace',
      'log',
      'error',
      'warn',
      'info',
      'debug',

      // Utility functions
      'decodeURI',
      'decodeURIComponent',
      'encodeURI',
      'encodeURIComponent',
      'escape',
      'unescape',
      'eval',
      'isFinite',
      'isNaN',
      'parseFloat',
      'parseInt',
      'getBoundingClientRect',
      'getRandomFluorescentColor',
      'lightenColor',
      'rgba',
      'showStatusMessage',
      'toFixed',
      'formatTime',

      // Language constructs
      'function',
      'if',
      'else',
      'for',
      'while',
      'do',
      'switch',
      'case',
      'default',
      'break',
      'continue',
      'return',
      'try',
      'catch',
      'finally',
      'throw',
      'new',
      'this',
      'super',
      'class',
      'extends',
      'static',
      'async',
      'await',
      'yield',
      'export',
      'import',
      'void',
      'typeof',
      'instanceof',
      'in',
      'delete',
      'with',
      'debugger',
      'var',
      'let',
      'const',
      'enum',
      'implements',
      'interface',
      'package',
      'private',
      'protected',
      'public',
      'arguments',
      'true',
      'false',
      'null',
      'undefined',
      'NaN',
      'Infinity',
      'globalThis',
      'callback',
      'next'
    ];

    let nodes = [];
    let connections = [];
    let draggingNode = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let connecting = null;
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let spacePressed = false;
    // 新增全局變量來追蹤當前活動的彈出框
    let activePopup = null;
    let popupScrollPosition = 0;
    // 在全局變量中添加
    let dragStartWorldX = 0;
    let dragStartWorldY = 0;
    // 新增全局變量
    let selectionBox = null;
    let isSelecting = false;
    let selectionStartX = 0;
    let selectionStartY = 0;
    let selectedNodes = new Set();
    let shiftPressed = false;
    let nodeDescriptions = {}; // 存儲節點描述
    // 全局變量來追蹤缺失的節點名稱
    let missingNodeNames = new Set();

    const FILTERED_NAMES = [
      '項目 1',]
    try {
      const saved = localStorage.getItem('nodeDescriptions');
      let nodeDescriptions = JSON.parse(localStorage.getItem('nodeDescriptions')) || {};
      if (saved) {
        nodeDescriptions = JSON.parse(saved);
      }
    } catch (e) {
      console.error('Failed to load descriptions from localStorage', e);
    }

    let lastVisibleNodes = []; // 記錄上次可見的節點
    // 追蹤動畫
    let animationFrameId = null;
    let currentLanguage = 'html'; // 默認語言
    //曲線顏色
    let currentColorIndex = 0;
    let currentConnectionColorIndex = 0; // 全局顏色索引
    // 修改現有的節點創建函數，在創建新節點時檢查缺失狀態
    const originalCreateNode = createNode;
    createNode = function (x, y, title = '節點', type = 'normal') {
      const newNode = originalCreateNode(x, y, title, type);

      // 如果創建的節點名稱在缺失列表中，重新檢查
      if (missingNodeNames.size > 0 && missingNodeNames.has(title)) {
        setTimeout(checkMissingNodes, 100);
      }

      return newNode;
    };

    const CONNECTION_COLORS = [
      '#FF6B6B', // 鮮豔紅色
      '#4ECDC4', // 青綠色
      '#45B7D1', // 亮藍色
      '#FFA07A', // 淺橙紅色
      '#98D8C8', // 綠松石色
      '#F06292', // 粉紅色
      '#7986CB', // 紫藍色
      '#9575CD', // 紫色
      '#64B5F6', // 天藍色
      '#4DB6AC', // 藍綠色
      '#81C784', // 草綠色
      '#FFD54F', // 金黃色
      '#FF8A65', // 深橙色
      '#A1887F', // 棕色
      '#90A4AE', // 灰藍色
      '#E57373'  // 亮紅色
    ];
    // 新增變量
    const transformContainer = document.getElementById('transform-container');
    let lastScale = 1;
    document.getElementById('save-btn').addEventListener('click', saveProject);
    document.getElementById('load-btn').addEventListener('click', () => {
      document.getElementById('file-input').click();
    });
    document.getElementById('file-input').addEventListener('change', loadProject);
    // Add this with the other button event listeners
    document.getElementById('load-html-btn').addEventListener('click', () => {
      const languageSelector = document.getElementById('code-language-selector');
      const currentLanguage = languageSelector ? languageSelector.value : 'html';

      // 根據當前語言設置文件輸入的accept屬性
      const fileInput = document.getElementById('html-file-input');
      fileInput.accept = currentLanguage === 'python' ? '.py' : '.html,.htm';
      fileInput.click();
    });
    document.getElementById('html-file-input').addEventListener('change', handleFileUpload);
    document.getElementById('code-language-selector').addEventListener('change', (e) => {
      currentLanguage = e.target.value;
      // 強制重新分析所有節點的變數
      nodes.forEach(node => {
        if (node.element.querySelector('.paragraph-input')?.value ||
          node.element.querySelector('.paragraph-popup')?.textContent) {
          analyzeVariables(node);
        }
      });
    });

    // 添加按鈕事件監聽器
    document.getElementById('check-missing-nodes-btn').addEventListener('click', checkMissingNodes);


    // 在 load-html-btn 右方添加新按鈕
    document.addEventListener('DOMContentLoaded', function () {
      const loadHtmlBtn = document.getElementById('load-html-btn');
      if (loadHtmlBtn) {
        const extractEmptyNodesBtn = document.createElement('button');
        extractEmptyNodesBtn.className = 'toolbar-btn';
        extractEmptyNodesBtn.id = 'extract-empty-nodes-btn';
        extractEmptyNodesBtn.textContent = '刪除所有空白NODE並提取名稱';

        // 插入到 load-html-btn 的右方
        loadHtmlBtn.parentNode.insertBefore(extractEmptyNodesBtn, loadHtmlBtn.nextSibling);

        // 添加點擊事件
        extractEmptyNodesBtn.addEventListener('click', extractEmptyNodesAndDelete);
      }
    });


    // 專門的格式化函數
    function formatNodeTitlesAsCSV(nodesArray) {
      if (!nodesArray || nodesArray.length === 0) {
        return '';
      }

      // 過濾掉空標題或未定義的標題
      const validTitles = nodesArray
        .map(node => node.title ? node.title.trim() : '')
        .filter(title => title !== '');

      // 新格式：每個標題用單引號包圍，並用逗號連接
      const quotedTitles = validTitles.map(title => `'${title}'`);
      return quotedTitles.join(',');
    }

    // 提取空白節點並刪除的主要函數
    function extractEmptyNodesAndDelete() {
      console.log('開始檢查空白節點...');

      // 1. 收集所有空的節點
      const emptyNodes = [];

      nodes.forEach(node => {
        if (node && node.element) {
          const paragraphInput = node.element.querySelector('.paragraph-input');
          if (paragraphInput && paragraphInput.value.trim() === '') {
            const nodeTitle = node.element.querySelector('.node-title');
            const title = nodeTitle ? nodeTitle.value : '未命名節點';

            emptyNodes.push({
              nodeId: node.id,
              title: title,
              element: node.element
            });

            console.log(`找到空白節點: ID=${node.id}, 標題="${title}"`);
          }
        }
      });

      if (emptyNodes.length === 0) {
        showStatusMessage('沒有找到空白節點', 'warning');
        return;
      }

      console.log(`總共找到 ${emptyNodes.length} 個空白節點`);

      // 2. 使用新的格式化函數
      const resultText = formatNodeTitlesAsCSV(emptyNodes);
      console.log('格式化結果:', resultText);

      // 3. 自動複製到剪貼板
      copyToClipboard(resultText);

      // 4. 自動選取這些節點
      selectEmptyNodes(emptyNodes);

      // 5. 顯示結果並確認刪除
      showDeleteConfirmation(emptyNodes, resultText);
    }

    // 複製文本到剪貼板
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        console.log('已複製結果到剪貼板:', text);
      }).catch(err => {
        console.error('複製失敗:', err);
        // 降級方案
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        console.log('使用降級方案複製成功');
      });
    }

    // 選取空白節點（參考 arrangeSelectedNodesVertically 的實現）
    function selectEmptyNodes(emptyNodes) {
      // 清除當前選取
      selectedNodes.clear();

      // 選取所有空白節點
      emptyNodes.forEach(emptyNode => {
        selectedNodes.add(emptyNode.nodeId);

        // 可選：添加視覺反饋
        const nodeElement = emptyNode.element;
        nodeElement.classList.add('selected');
      });

      console.log(`已選取 ${emptyNodes.length} 個空白節點`);
    }

    // 顯示刪除確認對話框
    function showDeleteConfirmation(emptyNodes, resultText) {
      const confirmMessage = `找到 ${emptyNodes.length} 個空白節點:\n\n${emptyNodes.map(node => `• ${node.title}`).join('\n')}\n\n節點名稱已複製到剪貼板: ${resultText}\n\n是否要刪除這些節點？`;

      if (confirm(confirmMessage)) {
        // 執行刪除
        deleteSelectedNodes();
        showStatusMessage(`已刪除 ${emptyNodes.length} 個空白節點，名稱已複製: ${resultText}`, 'success');
      } else {
        // 取消刪除，清除選取狀態
        selectedNodes.clear();
        document.querySelectorAll('.node.selected').forEach(node => {
          node.classList.remove('selected');
        });
        showStatusMessage('已取消刪除操作', 'info');
      }
    }


    // 垂直排列選中節點的函數
    function arrangeSelectedNodesVertically() {
      if (selectedNodes.size === 0) {
        showStatusMessage('請先選擇要排列的節點', 'warning');
        return;
      }

      console.log('開始垂直排列選中的節點...');

      // 1. 獲取選中的節點
      const selectedNodeIds = Array.from(selectedNodes);
      const selectedNodesArray = selectedNodeIds.map(id => nodes[id]);

      // 2. 按子節點數量排序：無子節點優先，最多子節點最後
      const sortedNodes = sortNodesByChildCount(selectedNodesArray);

      // 3. 找到最頂部的Y坐標作為起始位置
      const startY = findTopmostYPosition(selectedNodesArray);
      const startX = findLeftmostXPosition(selectedNodesArray);

      // 4. 垂直排列節點
      const verticalSpacing = 50; // 節點間的垂直間距

      sortedNodes.forEach((node, index) => {
        node.x = startX;
        node.y = startY + (index * verticalSpacing);
        updateNodePosition(node);
      });

      drawConnections();
      showStatusMessage(`已垂直排列 ${selectedNodes.size} 個節點（無子節點優先）`, 'success');
    }

    // 選取所有顯示 jump-to-btn 的節點
    function selectAllJumpNodes() {
      clearSelection();

      let jumpNodeCount = 0;

      nodes.forEach(node => {
        const jumpBtn = node.element.querySelector('.jump-to-btn');
        // 檢查按鈕是否存在且不是隱藏狀態
        if (jumpBtn && !jumpBtn.classList.contains('hidden') && jumpBtn.style.display !== 'none') {
          selectedNodes.add(node.id);
          node.element.classList.add('selected');
          jumpNodeCount++;
        }
      });

      drawConnections();

      if (jumpNodeCount > 0) {
        showStatusMessage(`已選取 ${jumpNodeCount} 個包含跳轉按鈕的節點`, 'success');
      } else {
        showStatusMessage('未找到任何顯示跳轉按鈕的節點', 'warning');
      }
    }// 按子節點數量排序節點
    function sortNodesByChildCount(nodeArray) {
      return nodeArray.sort((a, b) => {
        const aChildCount = getChildNodeCount(a.id);
        const bChildCount = getChildNodeCount(b.id);

        // 無子節點的排在最前面
        if (aChildCount === 0 && bChildCount > 0) return -1;
        if (aChildCount > 0 && bChildCount === 0) return 1;

        // 都有子節點時，子節點數量少的排在前面
        if (aChildCount > 0 && bChildCount > 0) {
          return aChildCount - bChildCount;
        }

        // 都無子節點時，保持原有順序
        return 0;
      });
    }


    // 找到選中節點中最頂部的Y坐標
    function findTopmostYPosition(nodeArray) {
      if (nodeArray.length === 0) return 0;

      let minY = Infinity;
      nodeArray.forEach(node => {
        if (node.y < minY) {
          minY = node.y;
        }
      });

      return minY;
    }

    // 找到選中節點中最左側的X坐標
    function findLeftmostXPosition(nodeArray) {
      if (nodeArray.length === 0) return 0;

      let minX = Infinity;
      nodeArray.forEach(node => {
        if (node.x < minX) {
          minX = node.x;
        }
      });

      return minX;
    }

    // 增強版的重新排列所有節點函數
    async function rearrangeAllNodesEnhanced() {
      console.log('開始增強版重新排列所有節點...');

      try {
        // 1. 首先收起所有節點
        collapseAllNodes();

        // 2. 按增強層級排列節點
        arrangeNodesByLevelEnhanced();

      } catch (error) {
        console.warn('節點排列過程中發生錯誤，但繼續執行後續操作:', error);
      }

      // 無論排列是否成功，都執行以下操作
      try {
        await drawConnections();

        // 使用 try-catch 跳過 selectAllJumpNodes 的錯誤
        try {
          selectAllJumpNodes();
        } catch (error) {
          console.warn('selectAllJumpNodes 執行時發生錯誤，但繼續執行:', error);
        }

        // 使用 try-catch 跳過 deleteSelectedNodes 的錯誤
        try {
          deleteSelectedNodes();
        } catch (error) {
          console.warn('deleteSelectedNodes 執行時發生錯誤，但繼續執行:', error);
        }

        showStatusMessage('已完成所有節點的增強版重新排列', 'success');
      } catch (error) {
        console.error('drawConnections 執行時發生錯誤:', error);
        showStatusMessage('重新排列節點時發生錯誤', 'error');
      }

      // 確保函數完成
      return Promise.resolve();
    }


    // 增強版按層級排列節點
    function arrangeNodesByLevelEnhanced() {
      // 找出所有根節點（沒有輸入連接的節點）
      const rootNodes = findRootNodes();

      if (rootNodes.length === 0) {
        console.log('未找到根節點');
        return;
      }

      console.log(`找到 ${rootNodes.length} 個根節點`);

      // 設置排列起始位置
      const startX = 50;
      const startY = 50;

      // 1. 對第1層節點進行增強排序
      const sortedFirstLevelNodes = sortFirstLevelNodes(rootNodes);
      console.log('第1層排序結果:', sortedFirstLevelNodes.map(node => ({
        title: node.element.querySelector('.node-title').value,
        childCount: getChildNodeCount(node.id),
        hasChildren: hasChildren(node.id)
      })));

      // 2. 排列第1層節點
      const firstLevelLayout = arrangeFirstLevelNodes(sortedFirstLevelNodes, startX, startY);

      // 3. 遞歸排列後續層級，保持第1層的順序
      arrangeSubsequentLevelsEnhanced(firstLevelLayout);
    }

    // 第1層節點排序函數
    function sortFirstLevelNodes(rootNodes) {
      return rootNodes.sort((a, b) => {
        const aChildCount = getChildNodeCount(a.id);
        const bChildCount = getChildNodeCount(b.id);
        const aHasChildren = hasChildren(a.id);
        const bHasChildren = hasChildren(b.id);

        // 規則1: 無子節點的排在最前面
        if (!aHasChildren && bHasChildren) return -1;
        if (aHasChildren && !bHasChildren) return 1;

        // 規則2: 都有子節點時，子節點數量少的排在前面
        if (aHasChildren && bHasChildren) {
          return aChildCount - bChildCount;
        }

        // 規則3: 都無子節點時，保持原有順序
        return 0;
      });
    }

    // 獲取節點的子節點數量
    function getChildNodeCount(nodeId) {
      return connections.filter(conn => conn.fromNode === nodeId).length;
    }

    // 檢查節點是否有子節點
    function hasChildren(nodeId) {
      return connections.some(conn => conn.fromNode === nodeId);
    }

    // 排列第1層節點並返回佈局信息
    function arrangeFirstLevelNodes(sortedNodes, startX, startY) {
      console.log(`排列第1層節點: ${sortedNodes.length} 個`);

      const layout = [];
      let currentX = startX;
      let currentY = startY;

      // 找到最左上角的節點作為第一個基準節點
      const topLeftNode = findTopLeftNodeFromArray(sortedNodes);
      const remainingNodes = sortedNodes.filter(node => node !== topLeftNode);

      if (topLeftNode) {
        // 移動基準節點到起始位置
        topLeftNode.x = currentX;
        topLeftNode.y = currentY;
        updateNodePosition(topLeftNode);

        // 記錄佈局信息
        layout.push({
          node: topLeftNode,
          childCount: getChildNodeCount(topLeftNode.id),
          children: getChildNodes(topLeftNode.id)
        });

        // 排列剩餘的第1層節點
        if (remainingNodes.length > 0) {
          alignNodeGroup(remainingNodes, topLeftNode, currentX, currentY);

          // 記錄所有節點的佈局信息
          remainingNodes.forEach(node => {
            layout.push({
              node: node,
              childCount: getChildNodeCount(node.id),
              children: getChildNodes(node.id)
            });
          });
        }

        // 按實際位置重新排序layout，確保順序正確
        layout.sort((a, b) => {
          const aX = a.node.x;
          const bX = b.node.x;
          const aY = a.node.y;
          const bY = b.node.y;

          if (aY !== bY) return aY - bY;
          return aX - bX;
        });
      }

      return layout;
    }

    // 獲取節點的所有直接子節點
    function getChildNodes(nodeId) {
      const childConnections = connections.filter(conn => conn.fromNode === nodeId);
      return childConnections.map(conn => nodes[conn.toNode]);
    }

    // 增強版排列後續層級
    function collectNextLevelNodesByParent(previousLevelLayout) {
      const nextLevelGroups = [];

      previousLevelLayout.forEach(parentInfo => {
        // 添加防護性檢查
        if (!parentInfo || !parentInfo.node) {
          console.warn('發現無效的 parentInfo，跳過該節點');
          return;
        }

        const childNodes = getChildNodes(parentInfo.node.id);

        if (childNodes.length > 0) {
          // 對子節點進行排序（如果有需要）
          const sortedChildren = sortChildNodes(childNodes);

          nextLevelGroups.push({
            parent: parentInfo.node,
            parentIndex: previousLevelLayout.indexOf(parentInfo),
            nodes: sortedChildren,
            childCount: childNodes.length
          });
        }
      });

      console.log(`收集到 ${nextLevelGroups.length} 個父節點組的子節點`);

      return nextLevelGroups;
    }

    // 按照父節點順序收集下一層節點
    function collectNextLevelNodesByParent(previousLevelLayout) {
      const nextLevelGroups = [];

      previousLevelLayout.forEach(parentInfo => {
        const childNodes = getChildNodes(parentInfo.node.id);

        if (childNodes.length > 0) {
          // 對子節點進行排序（如果有需要）
          const sortedChildren = sortChildNodes(childNodes);

          nextLevelGroups.push({
            parent: parentInfo.node,
            parentIndex: previousLevelLayout.indexOf(parentInfo),
            nodes: sortedChildren,
            childCount: childNodes.length
          });
        }
      });

      console.log(`收集到 ${nextLevelGroups.length} 個父節點組的子節點`);

      return nextLevelGroups;
    }

    // 子節點排序函數（可根據需要擴展）
    function sortChildNodes(childNodes) {
      // 目前保持原有順序，可以根據需要添加排序邏輯
      return childNodes;
    }




    // 添加重新排列所有節點的函數
    function rearrangeAllNodes() {
      console.log('開始重新排列所有節點...');

      // 1. 首先收起所有節點
      collapseAllNodes();

      // 2. 按層級排列節點
      arrangeNodesByLevel();

      drawConnections();
      showStatusMessage('已完成所有節點的重新排列', 'success');
    }

    // 收起所有節點
    function collapseAllNodes() {
      nodes.forEach(node => {
        const collapseBtn = node.element.querySelector('.collapse-btn');
        if (collapseBtn && collapseBtn.textContent === '-') {
          collapseBtn.click(); // 點擊收起按鈕
        }
      });
    }

    // 按層級排列節點
    function arrangeNodesByLevel() {
      // 找出所有根節點（沒有輸入連接的節點）
      const rootNodes = findRootNodes();

      if (rootNodes.length === 0) {
        console.log('未找到根節點');
        return;
      }

      console.log(`找到 ${rootNodes.length} 個根節點`);

      // 設置排列起始位置
      const startX = 50;
      const startY = 50;
      let currentX = startX;
      let currentY = startY;

      // 排列根節點（第1層）
      const firstLevelNodes = rootNodes;
      console.log(`排列第1層節點: ${firstLevelNodes.length} 個`);

      // 找到最左上角的根節點作為基準
      const topLeftNode = findTopLeftNodeFromArray(firstLevelNodes);
      if (topLeftNode) {
        // 將最左上角節點移到起始位置
        topLeftNode.x = currentX;
        topLeftNode.y = currentY;
        updateNodePosition(topLeftNode);

        // 從節點列表中移除已處理的節點
        const remainingNodes = firstLevelNodes.filter(node => node !== topLeftNode);

        if (remainingNodes.length > 0) {
          // 使用 multiColumnAlignNodes 邏輯排列剩餘的第1層節點
          alignNodeGroup(remainingNodes, topLeftNode, currentX, currentY);
        }

        // 更新當前Y位置為下一層的起始位置
        currentY = getBottomPosition(topLeftNode) + 100;
      }

      // 遞歸排列後續層級
      let currentLevel = 2;
      let previousLevelNodes = firstLevelNodes;

      while (previousLevelNodes.length > 0) {
        const nextLevelNodes = findNextLevelNodes(previousLevelNodes);

        if (nextLevelNodes.length === 0) {
          break;
        }

        console.log(`排列第${currentLevel}層節點: ${nextLevelNodes.length} 個`);

        // 設置下一層的起始X位置（在上一層右側）
        const levelStartX = getRightmostPosition(previousLevelNodes) + 200;
        const levelStartY = startY;

        // 排列下一層節點
        arrangeLevelNodes(nextLevelNodes, levelStartX, levelStartY);

        previousLevelNodes = nextLevelNodes;
        currentLevel++;
      }
    }

    // 找到所有根節點（沒有輸入連接的節點）
    function findRootNodes() {
      const nodesWithInput = new Set();

      connections.forEach(conn => {
        nodesWithInput.add(conn.toNode);
      });

      return nodes.filter(node => !nodesWithInput.has(node.id));
    }

    // 從節點數組中找到最左上角的節點
    function findTopLeftNodeFromArray(nodeArray) {
      let topLeftNode = null;
      let minX = Infinity;
      let minY = Infinity;

      nodeArray.forEach(node => {
        if (node.x < minX || (node.x === minX && node.y < minY)) {
          minX = node.x;
          minY = node.y;
          topLeftNode = node;
        }
      });

      return topLeftNode;
    }

    // 使用 multiColumnAlignNodes 的邏輯排列節點組
    function alignNodeGroup(nodeGroup, baseNode, startX, startY) {
      if (nodeGroup.length === 0) return;

      // 創建臨時的 selectedNodes Set
      const tempSelectedNodes = new Set(nodeGroup.map(node => node.id));

      // 保存原始的 selectedNodes
      const originalSelectedNodes = selectedNodes;

      // 設置臨時的 selectedNodes
      selectedNodes = tempSelectedNodes;

      // 使用 multiColumnAlignNodes 的排列邏輯
      const VERTICAL_SPACING = 10;
      const HORIZONTAL_SPACING = 30;

      // 將節點分組到各列
      const columns = groupNodesIntoColumns(baseNode, tempSelectedNodes, nodes);

      // 排列所有列
      arrangeColumns(columns, baseNode, HORIZONTAL_SPACING, VERTICAL_SPACING, nodes);

      // 恢復原始的 selectedNodes
      selectedNodes = originalSelectedNodes;
    }

    // 找到下一層節點（當前層節點的所有子節點）
    function findNextLevelNodes(currentLevelNodes) {
      const nextLevelNodeIds = new Set();

      currentLevelNodes.forEach(node => {
        // 找到從當前節點出發的所有連接
        const outgoingConnections = connections.filter(conn => conn.fromNode === node.id);

        outgoingConnections.forEach(conn => {
          nextLevelNodeIds.add(conn.toNode);
        });
      });

      return nodes.filter(node => nextLevelNodeIds.has(node.id));
    }

    // 獲取節點組的最右位置
    function getRightmostPosition(nodeArray) {
      let maxRight = -Infinity;

      nodeArray.forEach(node => {
        const nodeRight = node.x + node.element.offsetWidth;
        if (nodeRight > maxRight) {
          maxRight = nodeRight;
        }
      });

      return maxRight;
    }

    // 獲取節點的底部位置
    function getBottomPosition(node) {
      return node.y + node.element.offsetHeight;
    }

    // 排列單層節點
    function arrangeLevelNodes(levelNodes, startX, startY) {
      if (levelNodes.length === 0) return;

      // 找到最左上角的節點作為該層的基準
      const topLeftNode = findTopLeftNodeFromArray(levelNodes);
      const remainingNodes = levelNodes.filter(node => node !== topLeftNode);

      if (topLeftNode) {
        // 移動基準節點到起始位置
        topLeftNode.x = startX;
        topLeftNode.y = startY;
        updateNodePosition(topLeftNode);

        if (remainingNodes.length > 0) {
          // 排列剩餘節點
          alignNodeGroup(remainingNodes, topLeftNode, startX, startY);
        }
      }
    }

    // 檢查缺失節點的主要函數
    function checkMissingNodes() {
      // 清除之前的高亮
      clearMissingHighlights();

      // 收集所有現有的節點名稱
      const existingNodeNames = new Set();
      nodes.forEach(node => {
        const titleElement = node.element.querySelector('.node-title');
        if (titleElement) {
          const nodeName = titleElement.value.trim();
          if (nodeName && !isFilteredName(nodeName)) {
            existingNodeNames.add(nodeName);
          }
        }
      });

      // 收集所有item-text中的名稱
      const allItemNames = new Set();
      const missingNames = new Set();

      // 遍歷所有節點的所有item-text
    nodes.forEach(node => {
        // 1. 提取 item-text 中的名稱（原有邏輯）
        const itemTexts = node.element.querySelectorAll('.item-text');
        itemTexts.forEach(item => {
            const itemName = item.value.trim();
            if (itemName && !isFilteredName(itemName) && !isInBlacklist(itemName)) {
                allItemNames.add(itemName);

                // 檢查是否在現有節點名稱中
                if (!existingNodeNames.has(itemName)) {
                    missingNames.add(itemName);

                    // 高亮顯示該item
                    item.parentElement.classList.add('highlight-missing');

                    // 同時高亮顯示包含這個item的節點
                    node.element.classList.add('highlight-missing');
                }
            }
        });

        // 2. 加強：提取節點內容中的 function 名稱
        extractFunctionNamesFromNodeContent(node, allItemNames, missingNames, existingNodeNames);
    });

      // 高亮顯示所有名稱在缺失列表中的節點
      nodes.forEach(node => {
        const titleElement = node.element.querySelector('.node-title');
        const nodeTitle = titleElement ? titleElement.value.trim() : '';
        if (nodeTitle && missingNames.has(nodeTitle)) {
          node.element.classList.add('highlight-missing');
        }
      });

      // 保存缺失的節點名稱
      missingNodeNames = missingNames;

      // 顯示結果
      if (missingNames.size > 0) {
        const missingList = Array.from(missingNames).join(', ');
        showStatusMessage(`發現 ${missingNames.size} 個未加入的節點名稱: ${missingList}`, 'warning');

        // 檢查節點數量限制
        if (generatedNodeCount >= 50) {
          showStatusMessage(`已達到節點數量限制 (${generatedNodeCount}/50)，停止自動處理`, 'warning');
          stopAutoProcessing();
          return;
        }

        // 只有在沒有正在進行的自動處理時才開始新的處理
        if (!autoProcessingInterval) {
          startAutoProcessing();
        }
      } else {
        showStatusMessage('所有項目名稱都有對應的節點！', 'success');
      }
    }

    // 新增：從節點內容中提取 function 名稱的函數
function extractFunctionNamesFromNodeContent(node, allItemNames, missingNames, existingNodeNames) {
    try {
        // 獲取節點的內容（從 paragraph-input 或其他內容元素）
        const contentElements = [
            node.element.querySelector('.paragraph-input'),
            node.element.querySelector('.node-content'),
            node.element.querySelector('.content-textarea')
        ].filter(el => el !== null);

        let content = '';
        contentElements.forEach(el => {
            if (el.value || el.textContent) {
                content += (el.value || el.textContent) + '\n';
            }
        });

        if (!content.trim()) return;

        // 提取 function 名稱的模式
        const functionPatterns = [
            // 匹配 functionName() 格式
            /\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\([^)]*\)\s*\{/g,
            // 匹配 .addEventListener('event', functionName)
            /\.addEventListener\s*\(\s*['"][^'"]*['"]\s*,\s*([a-zA-Z_$][a-zA-Z0-9_$]*)/g,
            // 匹配 const/let/var functionName = function
            /\b(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*function/g,
            // 匹配 function functionName()
            /\bfunction\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g,
            // 匹配 arrow functions: const func = () =>
            /\b(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*\([^)]*\)\s*=>/g,
            // 匹配 object methods: methodName() {
            /\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(\s*\)\s*\{/g,
            // 匹配 callback functions in parameters
            /,\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\)/g
        ];

        const foundFunctions = new Set();

        // 使用所有模式進行匹配
        functionPatterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(content)) !== null) {
                const functionName = match[1];
                if (functionName && 
                    !isFilteredName(functionName) && 
                    !isInBlacklist(functionName) &&
                    functionName.length > 1 && // 排除單字符名稱
                    !functionName.match(/^[0-9]/) && // 排除數字開頭的名稱
                    !foundFunctions.has(functionName)) {
                    
                    foundFunctions.add(functionName);
                    allItemNames.add(functionName);

                    // 檢查是否在現有節點名稱中
                    if (!existingNodeNames.has(functionName)) {
                        missingNames.add(functionName);
                        // 高亮顯示整個節點（因為是在節點內容中找到的）
                        node.element.classList.add('highlight-missing');
                    }
                }
            }
        });

        // 特別處理事件監聽器中的函數名稱（您的範例情況）
        const eventListenerPattern = /\.addEventListener\s*\(\s*['"]([^'"]*)['"]\s*,\s*([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
        let eventMatch;
        while ((eventMatch = eventListenerPattern.exec(content)) !== null) {
            const eventName = eventMatch[1];
            const handlerName = eventMatch[2];
            
            if (handlerName && 
                !isFilteredName(handlerName) && 
                !isInBlacklist(handlerName) &&
                !foundFunctions.has(handlerName)) {
                
                foundFunctions.add(handlerName);
                allItemNames.add(handlerName);

                if (!existingNodeNames.has(handlerName)) {
                    missingNames.add(handlerName);
                    node.element.classList.add('highlight-missing');
                }
            }
        }

        console.log(`從節點 ${node.id} 中提取的函數:`, Array.from(foundFunctions));

    } catch (error) {
        console.warn(`提取節點 ${node.id} 內容中的函數名稱時出錯:`, error);
    }
}

    function isFilteredName(name) {
      return FILTERED_NAMES.includes(name) ||
        name.startsWith('項目 ') ||
        name.startsWith('item ');
    }


    // 檢查是否在黑名單中（支援多語言）
    function isInBlacklist(name) {
      if (currentLanguage === 'python') {
        return PYTHON_FUNCTION_BLACKLIST.includes(name);
      } else {
        return FUNCTION_BLACKLIST.includes(name);
      }
    }
    // 清除缺失高亮
    function clearMissingHighlights() {
      // 清除節點高亮
      document.querySelectorAll('.node.highlight-missing').forEach(node => {
        node.classList.remove('highlight-missing');
      });

      // 清除項目高亮
      document.querySelectorAll('.item.highlight-missing').forEach(item => {
        item.classList.remove('highlight-missing');
      });

      missingNodeNames.clear();
    }

    // 重新檢查缺失節點（用於名稱更新時）
    function recheckMissingNodes() {
      if (missingNodeNames.size > 0) {
        checkMissingNodes();
      }
    }


    // 監聽節點標題變化，自動檢查並取消高亮
    function setupMissingNodeCheckOnTitleChange() {
      // 監聽所有節點標題的變化
      document.addEventListener('input', (e) => {
        if (e.target.classList.contains('node-title')) {
          const newTitle = e.target.value.trim();

          // 如果當前有缺失檢查，重新檢查
          if (missingNodeNames.size > 0) {
            // 延遲重新檢查，避免頻繁觸發
            clearTimeout(window.missingCheckTimeout);
            window.missingCheckTimeout = setTimeout(recheckMissingNodes, 300);
          }
        }
      });

      // 監聽項目文本變化
      document.addEventListener('input', (e) => {
        if (e.target.classList.contains('item-text')) {
          // 如果當前有缺失檢查，重新檢查
          if (missingNodeNames.size > 0) {
            clearTimeout(window.missingCheckTimeout);
            window.missingCheckTimeout = setTimeout(recheckMissingNodes, 300);
          }
        }
      });
    }


    // 修改節點創建函數來監聽缺失狀態
    function setupMissingNodeMonitoring() {
      const originalCreateNode = window.createNode;

      window.createNode = function (x, y, title = '節點', type = 'normal') {
        const newNode = originalCreateNode(x, y, title, type);

        // 如果創建的節點名稱在缺失列表中，重新檢查
        if (missingNodeNames.size > 0) {
          setTimeout(recheckMissingNodes, 100);
        }

        return newNode;
      };
    }

    // 在初始化時設置監聽
    document.addEventListener('DOMContentLoaded', function () {
      setupMissingNodeCheckOnTitleChange();
      setupMissingNodeMonitoring();
      const rearrangeBtn = document.getElementById('rearrange-all-btn');
      if (rearrangeBtn) {
        rearrangeBtn.addEventListener('click', rearrangeAllNodes);
      }
    });


    // 修改現有的節點刪除功能
    function setupMissingNodeDeleteMonitoring() {
      // 保存原始的刪除節點邏輯引用
      const originalDeleteHandler = nodesContainer.addEventListener;

      // 監聽節點刪除事件
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-node-btn')) {
          // 如果當前有缺失檢查，在節點刪除後重新檢查
          if (missingNodeNames.size > 0) {
            setTimeout(recheckMissingNodes, 100);
          }
        }
      });
    }

    // 在初始化時設置監聽
    function initMissingNodeCheck() {
      setupMissingNodeCheckOnTitleChange();
      setupMissingNodeMonitoring();
      setupMissingNodeDeleteMonitoring();
    }

    // 在文檔加載完成後初始化
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMissingNodeCheck);
    } else {
      initMissingNodeCheck();
    }





    // 在初始化時添加快速修復按鈕
    //setTimeout(addQuickFixButton, 1000);

    // 在初始化時設置監聽
    setupMissingNodeCheckOnTitleChange();

    // 保存項目
    function saveProject() {
      try {
        // 獲取當前載入的 HTML 函數
        const loadedFunctions = JSON.parse(localStorage.getItem('loadedHtmlFunctions') || '{}');

        const nodesData = nodes.map(node => {
          const element = node.element;

          // 基本節點數據
          const nodeData = {
            id: node.id,
            x: node.x,
            y: node.y,
            colorIndex: node.colorIndex || 0,
            title: element.querySelector('.node-title').value || '未命名節點',
            isFrame: node.isFrame || false,
            metadata: {
              lastUpdated: new Date().toISOString()
            }
          };

          // 如果是普通節點
          if (!node.isFrame) {
            let content = '';
            const inputField = element.querySelector('.paragraph-input');
            const contentBtn = element.querySelector('.paragraph-btn');
            const popup = element.querySelector('.paragraph-popup');

            if (contentBtn && popup) {
              content = popup.textContent || contentBtn.dataset.originalContent || '';
            } else if (inputField) {
              content = inputField.value;
            }

            // 收集變數分析按鈕狀態
            const variableButtons = Array.from(element.querySelectorAll('.variable-btn'));
            const variableStates = variableButtons.map(btn => ({
              name: btn.dataset.variableName,
              active: btn.dataset.active === 'true'
            }));

            // 添加普通節點特有屬性
            Object.assign(nodeData, {
              content: content,
              description: nodeDescriptions[node.id] || '',
              isConvertedToButton: !!contentBtn,
              isChildrenHidden: element.classList.contains('children-hidden'),
              isCollapsed: element.classList.contains('collapsed'),
              items: Array.from(element.querySelectorAll('.item-text')).map(item => item.value),
              variableStates: variableStates,
              variableAnalysisExpanded: element.querySelector('.variable-analysis-container')?.classList.contains('expanded') || false,
              metadata: {
                contentLength: content.length,
                lastUpdated: new Date().toISOString()
              }
            });

            // 如果是群組節點，保存額外信息
            if (node.isGroupNode) {
              nodeData.isGroupNode = true;
              nodeData.containedNodes = node.containedNodes || [];
              nodeData.originalConnections = node.originalConnections || [];
              nodeData.incomingConnections = node.incomingConnections || [];
              nodeData.outgoingConnections = node.outgoingConnections || [];

              nodeData.originalConnections = node.originalConnections || [];

              nodeData.incomingConnections = connections
                .filter(conn => conn.toNode === node.id)
                .map(conn => ({
                  fromNode: conn.fromNode,
                  fromOutput: conn.fromOutput,
                  toNode: conn.toNode
                }));

              nodeData.outgoingConnections = connections
                .filter(conn => conn.fromNode === node.id)
                .map(conn => ({
                  fromNode: conn.fromNode,
                  fromOutput: conn.fromOutput,
                  toNode: conn.toNode
                }));
            }
          }
          // 如果是框架節點
          else {
            nodeData.width = parseFloat(element.style.width) || element.offsetWidth;
            nodeData.height = parseFloat(element.style.height) || element.offsetHeight;

            const contentArea = element.querySelector('.frame-content');
            if (contentArea) {
              nodeData.content = Array.from(contentArea.querySelectorAll('.frame-note')).map(note => ({
                text: note.textContent,
                style: note.style.cssText
              }));
            }
          }

          return nodeData;
        });

        const connectionsData = connections.map(conn => ({
          fromNode: conn.fromNode,
          fromOutput: conn.fromOutput || 0,
          toNode: conn.toNode,
          highlighted: conn.highlighted || false
        }));

        const projectData = {
          version: '2.8',
          nodes: nodesData,
          connections: connectionsData,
          nodeDescriptions: nodeDescriptions,
          loadedHtmlFunctions: loadedHtmlFunctions, // 保存到項目文件中
          viewState: {
            scale,
            translateX,
            translateY
          },
          savedAt: new Date().toISOString()
        };

        const dataStr = JSON.stringify(projectData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const filename = `node-project-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.style.display = 'none';

        document.body.appendChild(link);
        link.click();

        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }, 100);
      } catch (error) {
        console.error('保存失敗:', error);
        alert(`保存錯誤: ${error.message}`);
      }
    }



    // 載入項目
    // 載入項目
    function loadProject(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const projectData = JSON.parse(e.target.result);

          nodesContainer.innerHTML = '';
          nodes = [];
          connections = [];
          ALL_ACTIVE_POPUPS.clear();
          activePopup = null;

          // 恢復 HTML 函數
          if (projectData.loadedHtmlFunctions) {
            loadedHtmlFunctions = projectData.loadedHtmlFunctions;
          }
          // 恢復描述資料
          if (projectData.nodeDescriptions) {
            nodeDescriptions = projectData.nodeDescriptions;
          } else {
            nodeDescriptions = {};
          }

          if (projectData.viewState) {
            scale = projectData.viewState.scale || 1;
            translateX = projectData.viewState.translateX || window.innerWidth / 2 - 100;
            translateY = projectData.viewState.translateY || window.innerHeight / 2 - 50;
            applyTransform();
          }

          const nodeMap = {};
          const groupNodesData = [];

          // 第一遍：創建所有普通節點和框架節點
          projectData.nodes?.forEach(nodeData => {
            if (nodeData.isGroupNode) {
              groupNodesData.push(nodeData);
              return;
            }

            if (nodeData.isFrame) {
              // 創建框架節點
              const frameNode = createNode(nodeData.x, nodeData.y, nodeData.title || '新框架');
              frameNode.isFrame = true;

              if (nodeData.colorIndex !== undefined) {
                const colorClass = COLOR_CLASSES[nodeData.colorIndex % COLOR_CLASSES.length];
                frameNode.element.classList.add(colorClass);
                frameNode.colorIndex = nodeData.colorIndex;
              }

              // 設置框架樣式
              const frameElement = frameNode.element;
              frameElement.classList.add('frame-node');
              frameElement.style.zIndex = '1';

              // 移除不必要的元素
              const paragraphInput = frameElement.querySelector('.paragraph-input');
              const itemsContainer = frameElement.querySelector('.items');
              const addItemBtn = frameElement.querySelector('.add-item-btn');
              const outputPort = frameElement.querySelector('.output-port');

              if (paragraphInput) paragraphInput.remove();
              if (itemsContainer) itemsContainer.remove();
              if (addItemBtn) addItemBtn.remove();
              if (outputPort) outputPort.remove();

              // 重建框架結構
              frameElement.innerHTML = `
            <div class="frame-header">
              <input type="text" class="node-title" value="${nodeData.title || '新框架'}">
              <button class="delete-node-btn">×</button>
            </div>
            <div class="frame-content"></div>
            <div class="frame-footer">
              <button class="add-note-btn">添加註釋</button>
              <div class="resize-handle"></div>
            </div>
          `;

              // 設置框架尺寸
              if (nodeData.width && nodeData.height) {
                frameElement.style.width = `${nodeData.width}px`;
                frameElement.style.height = `${nodeData.height}px`;
              }

              // 恢復框架內容
              const contentArea = frameElement.querySelector('.frame-content');
              if (nodeData.content && contentArea) {
                nodeData.content.forEach(noteData => {
                  const note = document.createElement('div');
                  note.className = 'frame-note';
                  note.contentEditable = 'true';
                  note.textContent = noteData.text;
                  note.style.cssText = noteData.style || '';
                  contentArea.appendChild(note);
                });
              }

              // 設置框架事件
              setupFrameEvents(frameNode);

              // 添加到節點列表
              nodesContainer.appendChild(frameElement);
              nodeMap[nodeData.id] = frameNode;
              return;
            }

            // 創建普通節點...
            const newNode = createNode(nodeData.x, nodeData.y, nodeData.title || '節點');
            nodeMap[nodeData.id] = newNode;

            const colorClass = COLOR_CLASSES[nodeData.colorIndex % COLOR_CLASSES.length];
            newNode.element.classList.add(colorClass);
            newNode.colorIndex = nodeData.colorIndex;

            // 恢復折疊狀態
            if (nodeData.isCollapsed) {
              newNode.element.classList.add('collapsed');
              const collapseBtn = newNode.element.querySelector('.collapse-btn');
              if (collapseBtn) {
                collapseBtn.textContent = '+';
                const originalPorts = newNode.element.querySelectorAll('.output-port:not(.header-port)');
                const headerPort = newNode.element.querySelector('.header-port');
                originalPorts.forEach(port => port.style.display = 'none');
                if (!headerPort) {
                  const port = document.createElement('div');
                  port.className = 'output-port header-port';
                  port.dataset.type = 'output';
                  port.style.display = 'block';
                  newNode.element.querySelector('.node-header').appendChild(port);
                } else {
                  headerPort.style.display = 'block';
                }
              }
            }

            const paragraphInput = newNode.element.querySelector('.paragraph-input');
            if (paragraphInput && nodeData.content !== undefined) {
              paragraphInput.value = nodeData.content;

              if (nodeData.isConvertedToButton && nodeData.content.trim()) {
                const btn = document.createElement('button');
                btn.className = 'paragraph-btn';
                btn.textContent = nodeData.content.length > 50
                  ? nodeData.content.substring(0, 47) + '...'
                  : nodeData.content;
                btn.dataset.originalContent = nodeData.content;

                const popup = document.createElement('div');
                popup.className = 'paragraph-popup';
                popup.textContent = nodeData.content;
                popup.classList.add(colorClass);

                const container = document.createElement('div');
                container.style.position = 'relative';
                container.style.display = 'inline-block';
                container.style.width = '100%';

                const originalInput = paragraphInput.cloneNode(true);
                originalInput.style.display = 'none';
                container.appendChild(originalInput);
                container.appendChild(btn);
                container.appendChild(popup);

                paragraphInput.replaceWith(container);
                setupParagraphButtonEvents(btn, popup, originalInput, newNode);
              }
            }

            const itemsContainer = newNode.element.querySelector('.items');
            if (itemsContainer && nodeData.items) {
              itemsContainer.innerHTML = '';
              newNode.outputs = [];

              nodeData.items.forEach((itemText, index) => {
                const newItem = document.createElement('div');
                newItem.className = 'item';
                newItem.innerHTML = `
              <span class="drag-handle">☰</span>
              <input type="text" class="item-text" value="${escapeHtml(itemText || '項目 ' + (index + 1))}">
              <button class="add-node-btn">+</button>
              <div class="output-port" data-type="output"></div>
            `;
                itemsContainer.appendChild(newItem);

                newNode.outputs.push(index);
                setupAddNodeButton(newItem, newNode, index, container);
                setupOutputPort(newItem, newNode, index, container);
                setupItemDragAndDrop(newNode.element, newNode);
              });
            }

            // 恢復變數分析狀態
            if (nodeData.content && nodeData.content.trim()) {
              analyzeVariables(newNode);

              if (nodeData.variableStates) {
                nodeData.variableStates.forEach(variableState => {
                  const btn = newNode.element.querySelector(`.variable-btn[data-variable-name="${variableState.name}"]`);
                  if (btn) {
                    btn.dataset.active = variableState.active.toString();
                    if (variableState.active) {
                      btn.style.backgroundColor = '#4a90e2';
                      btn.style.color = 'white';
                    }
                  }
                });
              }

              const analysisContainer = newNode.element.querySelector('.variable-analysis-container');
              const toggleBtn = newNode.element.querySelector('.toggle-variable-analysis-btn');
              if (analysisContainer && toggleBtn) {
                if (nodeData.variableAnalysisExpanded) {
                  analysisContainer.classList.add('expanded');
                  toggleBtn.textContent = '-';
                } else {
                  analysisContainer.classList.remove('expanded');
                  toggleBtn.textContent = '+';
                }
              }
            }

            newNode.childStates = new Map();
            const childNodes = projectData.connections
              ?.filter(conn => conn.fromNode === nodeData.id)
              .map(conn => projectData.nodes.find(n => n.id === conn.toNode));

            if (childNodes && childNodes.length > 0) {
              childNodes.forEach((childData) => {
                if (childData) {
                  newNode.childStates.set(childData.id, {
                    x: childData.x,
                    y: childData.y,
                    collapsed: childData.isCollapsed || false
                  });
                }
              });
            }

            if (nodeData.isChildrenHidden) {
              newNode.element.classList.add('children-hidden');
              const hideChildrenBtn = newNode.element.querySelector('.hide-children-btn');
              if (hideChildrenBtn) {
                hideChildrenBtn.textContent = '顯示子';

                const currentChildNodes = connections
                  .filter(conn => conn.fromNode === newNode.id)
                  .map(conn => nodes[conn.toNode]);

                currentChildNodes.forEach((child, index) => {
                  if (!newNode.childStates.has(child.id)) {
                    newNode.childStates.set(child.id, {
                      x: child.x,
                      y: child.y,
                      collapsed: child.element.classList.contains('collapsed')
                    });
                  }

                  if (!child.element.classList.contains('collapsed')) {
                    child.element.querySelector('.collapse-btn').click();
                  }

                  child.x = newNode.x + 200 / scale;
                  child.y = newNode.y + (index * 43 / scale);
                  updateNodePosition(child);
                });
              }
            }
          });

          // 第二遍：創建群組節點並處理連接
          groupNodesData.forEach(nodeData => {
            const groupNodeElement = createGroupNodeElement(nodeData.x, nodeData.y, nodeData.title);
            const groupNodeData = initializeGroupNodeData(
              groupNodeElement,
              nodeData.x,
              nodeData.y,
              nodeData.containedNodes || []
            );

            groupNodeData.isGroupNode = true;
            groupNodeData.originalConnections = nodeData.originalConnections || [];
            groupNodeData.incomingConnections = nodeData.incomingConnections || [];
            groupNodeData.outgoingConnections = nodeData.outgoingConnections || [];

            setupUngroupButton(groupNodeElement, groupNodeData);

            nodeData.containedNodes?.forEach(nodeId => {
              if (nodeMap[nodeId] && nodeMap[nodeId].element) {
                nodeMap[nodeId].element.style.display = 'none';
              }
            });

            nodeMap[nodeData.id] = groupNodeData;
          });

          // 第三遍：恢復所有連接
          projectData.connections?.forEach(conn => {
            const fromNodeExists = nodeMap[conn.fromNode] !== undefined;
            const toNodeExists = nodeMap[conn.toNode] !== undefined;

            if (fromNodeExists && toNodeExists) {
              connections.push({
                fromNode: nodeMap[conn.fromNode].id,
                fromOutput: conn.fromOutput || 0,
                toNode: nodeMap[conn.toNode].id
              });
            } else {
              console.warn('Invalid connection found:', conn);
            }
          });

          // 特別處理群組節點的連接關係
          groupNodesData.forEach(nodeData => {
            const groupNode = nodeMap[nodeData.id];
            if (!groupNode) return;

            groupNode.incomingConnections.forEach(conn => {
              if (nodeMap[conn.fromNode] && nodeMap[conn.toNode]) {
                connections.push({
                  fromNode: nodeMap[conn.fromNode].id,
                  fromOutput: conn.fromOutput,
                  toNode: groupNode.id
                });
              }
            });

            groupNode.outgoingConnections.forEach(conn => {
              if (nodeMap[conn.fromNode] && nodeMap[conn.toNode]) {
                connections.push({
                  fromNode: groupNode.id,
                  fromOutput: conn.fromOutput,
                  toNode: nodeMap[conn.toNode].id
                });
              }
            });
          });

          drawConnections();
          showStatusMessage('項目載入完成', 'success');
        } catch (error) {
          console.error('載入失敗:', error);
          showStatusMessage('載入失敗，請檢查文件格式', 'error');
        }
      };

      reader.readAsText(file);
      event.target.value = '';
    }
    function setupFrameEvents(frameNode) {
      const frameElement = frameNode.element;

      // 設置刪除按鈕事件
      frameElement.querySelector('.delete-node-btn').addEventListener('click', (e) => {
        connections = connections.filter(conn =>
          conn.fromNode !== frameNode.id && conn.toNode !== frameNode.id
        );
        nodes = nodes.filter(n => n.id !== frameNode.id);
        frameElement.remove();
        drawConnections();
        e.stopPropagation();
      });

      // 設置調整大小手柄
      const resizeHandle = frameElement.querySelector('.resize-handle');
      let isResizing = false;
      let startWidth, startHeight, startX, startY;

      // 移除舊事件監聽器
      const oldResizeHandle = resizeHandle.cloneNode(true);
      resizeHandle.parentNode.replaceChild(oldResizeHandle, resizeHandle);

      // 添加新事件監聽器
      oldResizeHandle.addEventListener('mousedown', function (e) {
        isResizing = true;
        startWidth = parseFloat(frameElement.style.width || frameElement.offsetWidth);
        startHeight = parseFloat(frameElement.style.height || frameElement.offsetHeight);
        startX = e.clientX;
        startY = e.clientY;
        e.stopPropagation();
        e.preventDefault();
      });

      document.addEventListener('mousemove', function (e) {

        if (e.target.closest('.frame-node')) {
          // Don't start selection if clicking on a frame-node
          return;
        }
        if (!isResizing) return;

        const dx = (e.clientX - startX) / scale;
        const dy = (e.clientY - startY) / scale;

        const newWidth = Math.max(300, startWidth + dx);
        const newHeight = Math.max(200, startHeight + dy);

        frameElement.style.width = `${newWidth}px`;
        frameElement.style.height = `${newHeight}px`;

        e.preventDefault();
      });

      document.addEventListener('mouseup', function () {
        isResizing = false;
      });

      // 設置註釋按鈕事件
      frameElement.querySelector('.add-note-btn').addEventListener('click', () => {
        const contentArea = frameElement.querySelector('.frame-content');
        const note = document.createElement('div');
        note.className = 'frame-note';
        note.contentEditable = 'true';
        contentArea.appendChild(note);
        note.focus();
      });
    }

    // In your selection logic (where you check which nodes are in the selection box):
    function selectNodesInBox(x1, y1, x2, y2) {
      clearSelection();

      const left = Math.min(x1, x2);
      const right = Math.max(x1, x2);
      const top = Math.min(y1, y2);
      const bottom = Math.max(y1, y2);

      nodes.forEach(node => {
        if (node.isFrame) return; // Skip frame nodes

        const rect = node.element.getBoundingClientRect();
        const nodeCenterX = (rect.left + rect.right) / 2;
        const nodeCenterY = (rect.top + rect.bottom) / 2;

        if (nodeCenterX > left && nodeCenterX < right &&
          nodeCenterY > top && nodeCenterY < bottom) {
          selectedNodes.add(node.id);
          node.element.classList.add('selected');
        }
      });

      drawConnections();
    }


    // 導出選中節點函數
    function exportSelectedNodes() {
      if (selectedNodes.size === 0) {
        showStatusMessage('請先選擇要導出的節點', 'warning');
        return;
      }

      try {
        // 只導出選中的節點，包含群組節點及其內部節點
        const nodesToExport = Array.from(selectedNodes);
        const allNodesToExport = new Set(nodesToExport);

        // 收集群組節點中包含的所有節點
        nodesToExport.forEach(nodeId => {
          const node = nodes[nodeId];
          if (node.isGroupNode && node.containedNodes) {
            node.containedNodes.forEach(containedId => {
              allNodesToExport.add(containedId);
            });
          }
        });

        // 準備節點數據
        const nodesData = Array.from(allNodesToExport).map(nodeId => {
          const node = nodes[nodeId];
          const element = node.element;

          // 獲取段落內容
          let content = '';
          const inputField = element.querySelector('.paragraph-input');
          const contentBtn = element.querySelector('.paragraph-btn');
          const popup = element.querySelector('.paragraph-popup');

          if (contentBtn && popup) {
            content = popup.textContent || contentBtn.dataset.originalContent || '';
          } else if (inputField) {
            content = inputField.value;
          }

          const nodeData = {
            id: node.id,
            x: node.x,
            y: node.y,
            colorIndex: node.colorIndex || 0,
            title: element.querySelector('.node-title').value || '未命名節點',
            content: content,
            description: nodeDescriptions[node.id] || '',
            isConvertedToButton: !!contentBtn,
            items: Array.from(element.querySelectorAll('.item-text')).map(item => item.value),
            metadata: {
              contentLength: content.length,
              lastUpdated: new Date().toISOString()
            }
          };

          // 如果是群組節點，保存額外信息
          if (node.isGroupNode) {
            nodeData.isGroupNode = true;
            nodeData.containedNodes = node.containedNodes || [];
          }

          return nodeData;
        });

        // 準備連接數據（僅包含導出節點之間的連接）
        const connectionsData = connections
          .filter(conn => {
            return allNodesToExport.has(conn.fromNode) && allNodesToExport.has(conn.toNode);
          })
          .map(conn => ({
            fromNode: conn.fromNode,
            fromOutput: conn.fromOutput || 0,
            toNode: conn.toNode
          }));

        // 創建導出數據
        const exportData = {
          version: '2.5',
          nodes: nodesData,
          connections: connectionsData,
          exportedAt: new Date().toISOString()
        };

        // 生成下載文件
        const dataStr = JSON.stringify(exportData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const filename = `selected-nodes-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.style.display = 'none';

        document.body.appendChild(link);
        link.click();

        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }, 100);

        showStatusMessage(`已導出 ${nodesToExport.length} 個選中節點`, 'success');
      } catch (error) {
        console.error('導出失敗:', error);
        showStatusMessage(`導出錯誤: ${error.message}`, 'error');
      }
    }
    // 導入選中節點函數
    function importSelectedNodes(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const projectData = JSON.parse(e.target.result);

          // 先清空現有資料
          nodesContainer.innerHTML = '';
          nodes = [];
          connections = [];
          ALL_ACTIVE_POPUPS.clear();
          activePopup = null;

          // 恢復描述資料 - 確保有預設值
          nodeDescriptions = projectData.nodeDescriptions || {};
          const importData = JSON.parse(e.target.result);

          if (!importData.nodes || !Array.isArray(importData.nodes)) {
            throw new Error('無效的導入文件格式');
          }

          // 計算導入位置偏移量（當前視圖中心）
          const centerX = toWorldX(window.innerWidth / 2);
          const centerY = toWorldY(window.innerHeight / 2);

          // 計算原始節點群的中心點
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          importData.nodes.forEach(node => {
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
            maxX = Math.max(maxX, node.x);
            maxY = Math.max(maxY, node.y);
          });
          const originalCenterX = (minX + maxX) / 2;
          const originalCenterY = (minY + maxY) / 2;

          // 計算偏移量
          const offsetX = centerX - originalCenterX;
          const offsetY = centerY - originalCenterY;

          // 創建ID映射表（舊ID -> 新ID）
          const idMap = {};
          let maxId = Math.max(...nodes.map(n => n.id), -1) + 1;

          // 先創建所有普通節點
          importData.nodes.forEach(nodeData => {
            if (nodeData.isGroupNode) return; // 群組節點稍後處理

            const newNode = createNode(
              nodeData.x + offsetX,
              nodeData.y + offsetY,
              nodeData.title || '節點'
            );

            // 記錄ID映射
            idMap[nodeData.id] = newNode.id;

            // 設置節點屬性
            if (nodeData.colorIndex !== undefined) {
              changeNodeColor(newNode, nodeData.colorIndex);
            }

            if (nodeData.description) {
              nodeDescriptions[newNode.id] = nodeData.description;
            }

            // 恢復段落內容
            setupNodeContent(newNode, nodeData);
          });

          // 處理群組節點
          importData.nodes.forEach(nodeData => {
            if (!nodeData.isGroupNode) return;

            // 創建群組節點
            const groupNode = createNode(
              nodeData.x + offsetX,
              nodeData.y + offsetY,
              nodeData.title || '群組節點',
              'group'
            );

            // 記錄ID映射
            idMap[nodeData.id] = groupNode.id;

            // 設置群組節點屬性
            if (nodeData.colorIndex !== undefined) {
              changeNodeColor(groupNode, nodeData.colorIndex);
            }

            // 設置包含的節點
            if (Array.isArray(nodeData.containedNodes)) {
              groupNode.containedNodes = nodeData.containedNodes.map(id => idMap[id]);

              // 隱藏被包含的節點
              groupNode.containedNodes.forEach(nodeId => {
                if (nodes[nodeId]) {
                  nodes[nodeId].element.style.display = 'none';
                }
              });
            }

            // 更新群組節點信息
            updateGroupNodeInfo(groupNode);
          });

          // 導入連接（僅包含內部連接）
          if (Array.isArray(importData.connections)) {
            importData.connections.forEach(conn => {
              if (idMap[conn.fromNode] !== undefined && idMap[conn.toNode] !== undefined) {
                connections.push({
                  fromNode: idMap[conn.fromNode],
                  fromOutput: conn.fromOutput || 0,
                  toNode: idMap[conn.toNode]
                });
              }
            });
          }

          drawConnections();
          updateNodeList();
          showStatusMessage(`已導入 ${importData.nodes.length} 個節點`, 'success');
        } catch (error) {
          console.error('導入失敗:', error);
          showStatusMessage('導入失敗，請檢查文件格式', 'error');
        }
      };

      reader.readAsText(file);
      event.target.value = '';
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const languageSelector = document.getElementById('code-language-selector');
      const currentLanguage = languageSelector ? languageSelector.value : 'html';

      const fileName = file.name.toLowerCase();
      let isValidFileType = false;
      let expectedExtensions = [];

      if (currentLanguage === 'python') {
        isValidFileType = fileName.endsWith('.py');
        expectedExtensions = ['.py'];
      } else {
        isValidFileType = fileName.endsWith('.html') || fileName.endsWith('.htm');
        expectedExtensions = ['.html', '.htm'];
      }

      if (!isValidFileType) {
        const allowedExtensions = expectedExtensions.join(' 或 ');
        showStatusMessage(
          `錯誤: 請上傳 ${currentLanguage === 'python' ? 'Python' : 'HTML'} 文件 (${allowedExtensions})`,
          'error'
        );
        event.target.value = '';
        return;
      }

      const reader = new FileReader();

      reader.onload = (e) => {
        try {
          const content = e.target.result;

          if (currentLanguage === 'python') {
            handlePythonFile(content);
          } else {
            handleHtmlFile(content);
          }

          showStatusMessage(`${file.name} 文件上傳成功`, 'success');

        } catch (error) {
          console.error('處理文件失敗:', error);
          showStatusMessage(`處理文件時發生錯誤: ${error.message}`, 'error');
        }
      };

      reader.onerror = (error) => {
        console.error('文件讀取錯誤:', error);
        showStatusMessage(`讀取文件失敗: ${error.message}`, 'error');
      };

      reader.readAsText(file, 'UTF-8');
      event.target.value = '';
    }
    function handlePythonFile(content) {
      // 解析Python文件內容
      const functionMap = {};

      // Python函數解析正則表達式
      const functionRegex = /def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\([^)]*\)\s*:\s*([\s\S]*?)(?=\n\S|\n$|\n\s*@|\n\s*def\s)/g;
      let match;

      while ((match = functionRegex.exec(content)) !== null) {
        const functionName = match[1];
        let functionBody = match[2].trim();

        // 處理縮進
        functionBody = functionBody.replace(/^\s+/gm, '');

        functionMap[functionName] = {
          code: `def ${functionName}(${match[0].split('(')[1].split(')')[0]}):\n${functionBody}`,
          start: match.index,
          end: match.index + match[0].length
        };
      }

      // 保存到內存中的全局變量
      loadedHtmlFunctions = functionMap;

      // 更新節點內容
      updateNodesWithFunctions(functionMap);

      // 新增：自動檢查並更新paragraph-btn內容（Python版本）
      autoUpdateParagraphButtons(functionMap);
    }



    function handleHtmlFile(content) {
      console.log('=== 開始解析HTML文件 ===');
      console.log('文件內容長度:', content.length);
      console.log('文件內容前500字符:', content.substring(0, 500));

      const functions = extractFunctions(content);

      console.log('解析完成，找到函數數量:', Object.keys(functions).length);

      // 詳細顯示每個函數
      Object.keys(functions).forEach((funcName, index) => {
        const funcData = functions[funcName];
        console.log(`函數 ${index + 1}: "${funcName}"`, {
          代碼長度: funcData.code.length,
          開始位置: funcData.start,
          結束位置: funcData.end,
          預覽: funcData.code.substring(0, 100) + '...'
        });
      });

      loadedHtmlFunctions = functions;

      showStatusMessage(`成功解析 ${Object.keys(functions).length} 個函數`, 'success');

      // 保存到全局變數以便調試
      window.debugFunctions = functions;

      // 立即檢查是否有 closeAllLists 函數
      if (functions.closeAllLists) {
        console.log('✅ 找到 closeAllLists 函數');
        console.log('closeAllLists 內容長度:', functions.closeAllLists.code.length);
        console.log('內容預覽:', functions.closeAllLists.code.substring(0, 200));
      } else {
        console.log('❌ 未找到 closeAllLists 函數');
        // 搜索所有包含 "closeAllLists" 的鍵
        const closeKeys = Object.keys(functions).filter(key =>
          key.toLowerCase().includes('closealllists') ||
          key.toLowerCase().includes('close')
        );
        console.log('相關的函數名:', closeKeys);
      }

      // 新增：自動檢查並更新paragraph-btn內容
      autoUpdateParagraphButtons(functions);
    }
    // 新增函數：自動檢查並更新paragraph-btn內容
    function autoUpdateParagraphButtons(functions) {
      let updateCount = 0;
      const updatedNodes = [];

      nodes.forEach(node => {
        const paragraphBtn = node.element.querySelector('.paragraph-btn');
        if (!paragraphBtn) return;

        const currentContent = paragraphBtn.dataset.originalContent || '';
        const nodeTitle = node.element.querySelector('.node-title')?.value.trim() || '';

        // 檢查是否有對應的函數內容
        if (functions[nodeTitle] && functions[nodeTitle].code) {
          const newContent = functions[nodeTitle].code;

          // 如果內容不同，則更新
          if (currentContent !== newContent) {
            // 更新paragraph-btn的內容
            paragraphBtn.dataset.originalContent = newContent;
            paragraphBtn.textContent = newContent.length > 50
              ? newContent.substring(0, 47) + '...'
              : newContent;

            // 更新對應的popup內容
            const popup = node.element.querySelector('.paragraph-popup');
            if (popup) {
              popup.textContent = newContent;
            }

            // 更新隱藏的input內容
            const hiddenInput = node.element.querySelector('.paragraph-input');
            if (hiddenInput) {
              hiddenInput.value = newContent;
            }

            updateCount++;
            updatedNodes.push(node);

            console.log(`✅ 更新節點 "${nodeTitle}" 的內容`);
          }
        }
      });

      // 顯示更新結果
      if (updateCount > 0) {
        showStatusMessage(`已自動更新 ${updateCount} 個節點的內容`, 'success');

        // 對更新的節點顯示黃框高亮5秒
        updatedNodes.forEach(node => {
          highlightNodeTemporarily(node);
        });
      } else {
        showStatusMessage('所有節點內容已是最新狀態', 'info');
      }
    }

    // 新增函數：暫時高亮節點（黃框顯示5秒）
    function highlightNodeTemporarily(node) {
      // 保存原始樣式
      const originalOutline = node.element.style.outline;
      const originalOutlineOffset = node.element.style.outlineOffset;
      const originalZIndex = node.element.style.zIndex;

      // 應用黃框高亮樣式
      node.element.style.outline = '3px solid #ffeb3b';
      node.element.style.outlineOffset = '2px';
      node.element.style.zIndex = '1000';
      node.element.style.transition = 'outline 0.3s ease';

      // 5秒後恢復原始樣式
      setTimeout(() => {
        node.element.style.outline = originalOutline;
        node.element.style.outlineOffset = originalOutlineOffset;
        node.element.style.zIndex = originalZIndex;
      }, 5000);
    }

    // 新增函數：創建新框架
    function addNewFrame() {
      // 計算新框架的位置
      let baseX = window.innerWidth / 2 - 150;
      let baseY = window.innerHeight / 2 - 100;

      if (nodes.length > 0) {
        const lastNode = nodes[nodes.length - 1];
        baseX = lastNode.x + 250 / scale;
        baseY = lastNode.y;
      }

      // 創建新框架
      const frameNode = createNode(baseX, baseY, '新框架');
      frameNode.isFrame = true; // 標記為框架

      // 設置默認顏色
      frameNode.colorIndex = 0; // 或其他默認顏色索引
      frameNode.element.classList.add(COLOR_CLASSES[frameNode.colorIndex]);

      // 設置框架樣式
      const frameElement = frameNode.element;
      frameElement.classList.add('frame-node');
      frameElement.style.zIndex = '1'; // 明確設置z-index

      // 移除不必要的元素
      const paragraphInput = frameElement.querySelector('.paragraph-input');
      const itemsContainer = frameElement.querySelector('.items');
      const addItemBtn = frameElement.querySelector('.add-item-btn');
      const outputPort = frameElement.querySelector('.output-port');

      if (paragraphInput) paragraphInput.remove();
      if (itemsContainer) itemsContainer.remove();
      if (addItemBtn) addItemBtn.remove();
      if (outputPort) outputPort.remove();

      // 重建框架結構，調整為更合理的佈局
      frameElement.innerHTML = `
    <div class="frame-header">
      <input type="text" class="node-title" value="新框架">
      <button class="delete-node-btn">×</button>
    </div>
    <div class="frame-content">
      <!-- 註釋將在這裡添加 -->
    </div>
    <div class="frame-notes-container"></div>
    <div class="frame-footer">
      <button class="add-note-btn">添加註釋</button>
      <div class="resize-handle"></div>
    </div>
  `;

      // 確保框架被添加到DOM底部
      frameElement.remove();
      nodesContainer.appendChild(frameElement);

      // 設置標題樣式
      const titleInput = frameElement.querySelector('.node-title');
      titleInput.style.textAlign = 'center';
      titleInput.style.fontWeight = 'bold';

      // 設置刪除按鈕事件
      frameElement.querySelector('.delete-node-btn').addEventListener('click', (e) => {
        connections = connections.filter(conn =>
          conn.fromNode !== frameNode.id && conn.toNode !== frameNode.id
        );
        nodes = nodes.filter(n => n.id !== frameNode.id);
        frameElement.remove();
        drawConnections();
        e.stopPropagation();
      });




      // 設置調整大小手柄
      const resizeHandle = frameElement.querySelector('.resize-handle');
      let isResizing = false;
      let startWidth, startHeight, startX, startY;



      frameElement.addEventListener('mousedown', (e) => {
        if (e.target === resizeHandle || e.target.closest('.delete-node-btn')) {
          return;
        }

        e.stopPropagation();

        // Get frame bounds
        const frameRect = frameElement.getBoundingClientRect();
        const frameLeft = toWorldX(frameRect.left);
        const frameTop = toWorldY(frameRect.top);
        const frameRight = toWorldX(frameRect.right);
        const frameBottom = toWorldY(frameRect.bottom);

        // Find all nodes inside this frame
        const containedNodes = nodes.filter(node => {
          if (node.isFrame || node.id === frameNode.id) return false;

          const nodeRect = node.element.getBoundingClientRect();
          const nodeCenterX = toWorldX((nodeRect.left + nodeRect.right) / 2);
          const nodeCenterY = toWorldY((nodeRect.top + nodeRect.bottom) / 2);

          return nodeCenterX > frameLeft && nodeCenterX < frameRight &&
            nodeCenterY > frameTop && nodeCenterY < frameBottom;
        });

        // Set up drag for frame and contained nodes
        draggingNode = frameNode;
        dragStartWorldX = toWorldX(e.clientX);
        dragStartWorldY = toWorldY(e.clientY);
        dragOffsetX = dragStartWorldX - frameNode.x;
        dragOffsetY = dragStartWorldY - frameNode.y;

        // Store initial positions of contained nodes relative to frame
        frameNode.containedNodes = containedNodes.map(node => ({
          node,
          offsetX: node.x - frameNode.x,
          offsetY: node.y - frameNode.y
        }));

        e.preventDefault();
      });




      resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startWidth = parseFloat(frameElement.style.width || frameElement.offsetWidth);
        startHeight = parseFloat(frameElement.style.height || frameElement.offsetHeight);
        startX = e.clientX;
        startY = e.clientY;

        e.stopPropagation();
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (isResizing) {
          const dx = (e.clientX - startX) / scale;
          const dy = (e.clientY - startY) / scale;

          const newWidth = Math.max(300, startWidth + dx);
          const newHeight = Math.max(200, startHeight + dy);

          frameElement.style.width = `${newWidth}px`;
          frameElement.style.height = `${newHeight}px`;

          e.preventDefault();
        }

      });

      document.addEventListener('mouseup', () => {
        isResizing = false;
      });

      // 設置註釋按鈕事件 - 修改為將註釋添加到 notes-container
      frameElement.querySelector('.add-note-btn').addEventListener('click', () => {
        const notesContainer = frameElement.querySelector('.frame-notes-container');
        const note = document.createElement('div');
        note.className = 'frame-note';
        note.contentEditable = 'true';
        note.style.margin = '5px';
        note.style.padding = '8px';
        note.style.backgroundColor = 'rgba(30, 30, 30, 0.7)'; // 暗黑模式背景色
        note.style.color = '#e0e0e0'; // 暗黑模式文字顏色
        note.style.borderRadius = '4px';
        note.style.minHeight = '20px';
        notesContainer.appendChild(note);
        note.focus();
      });

      // 添加CSS樣式以確保正確的佈局（暗黑模式版本）
      const style = document.createElement('style');
      style.textContent = `
    .frame-node {
      display: flex;
      flex-direction: column;
      min-width: 300px;
      min-height: 200px;
      position: absolute;
      background-color: #2d2d2d; /* 暗黑背景 */
      border: 2px solid #444; /* 暗黑邊框 */
      border-radius: 8px;
      overflow: hidden;
      color: #e0e0e0; /* 暗黑文字顏色 */
      user-select: none;
  -webkit-user-select: none;
  pointer-events: auto; /* Ensure it can still be dragged */
    }

.frame-node * {
  user-select: none;
  -webkit-user-select: none;
}
.frame-header {
  padding: 8px;
  background-color: var(--primary-bg);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: var(--text-color); /* 確保文字可讀 */
  transition: background-color 0.2s ease; /* 添加平滑過渡 */
}

.frame-header:hover {
  background-color: #252525; /* 懸停時略微變亮 */
}

.frame-content {
  flex-grow: 1;
  padding: 8px;
  overflow-y: auto;
  background-color: var(--secondary-bg);
  color: var(--text-color);
}

/* 自定義滾動條樣式 */
.frame-content::-webkit-scrollbar {
  width: 8px;
}
.frame-content::-webkit-scrollbar-track {
  background: var(--primary-bg);
}
.frame-content::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 4px;
}

.frame-notes-container {
  padding: 8px;
  background-color: var(--primary-bg);
  border-top: 1px solid var(--border-color);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 8px;
  color: var(--text-color);
}

.frame-footer {
  height: 16px;
  background-color: var(--footer-bg); /* 統一暗黑主題 */
  cursor: nwse-resize;
  transition: background-color 0.2s ease;
}

.frame-footer:hover {
  background-color: #3a3a3a; /* 懸停時變亮 */
}
  `;
      document.head.appendChild(style);
    }




    function colorizeChildConnections(parentNodeId) {
      // 找出所有直接子節點連接
      const childConnections = connections.filter(conn =>
        conn.fromNode === parentNodeId
      );

      // 為每個子連接分配不同的顏色
      childConnections.forEach((conn, index) => {
        conn.colorClass = `color-${index % CONNECTION_COLORS.length}`;
      });
    }


    function updateNodesWithFunctions(functionMap) {
      let updateCount = 0;
      const updatedNodes = [];

      nodes.forEach(node => {
        const titleElement = node.element.querySelector('.node-title');
        if (titleElement) {
          const nodeName = titleElement.value.trim();
          if (functionMap[nodeName] && functionMap[nodeName].code) {
            // 找到匹配的函數 - 更新節點內容
            updateNodeContent(node, functionMap[nodeName].code);
            updateCount++;
            updatedNodes.push(node);
          }
        }
      });

      if (updateCount > 0) {
        showStatusMessage(`已更新 ${updateCount} 個節點的內容`, 'success');

        // 對更新的節點顯示黃框高亮5秒
        updatedNodes.forEach(node => {
          highlightNodeTemporarily(node);
        });
      } else {
        showStatusMessage('未找到匹配的函數名稱', 'warning');
      }
    }

    function setupNodeContent(newNode, nodeData) {
      const paragraphInput = newNode.element.querySelector('.paragraph-input');
      if (paragraphInput && nodeData.content !== undefined) {
        paragraphInput.value = nodeData.content;

        if (nodeData.isConvertedToButton && nodeData.content.trim()) {
          const btn = document.createElement('button');
          btn.className = 'paragraph-btn';
          btn.textContent = nodeData.content.length > 50
            ? nodeData.content.substring(0, 47) + '...'
            : nodeData.content;
          btn.dataset.originalContent = nodeData.content;

          const popup = document.createElement('div');
          popup.className = 'paragraph-popup';
          popup.textContent = nodeData.content;
          popup.classList.add(COLOR_CLASSES[nodeData.colorIndex % COLOR_CLASSES.length]);

          const container = document.createElement('div');
          container.style.position = 'relative';
          container.style.display = 'inline-block';
          container.style.width = '100%';

          const originalInput = paragraphInput.cloneNode(true);
          originalInput.style.display = 'none';
          container.appendChild(originalInput);
          container.appendChild(btn);
          container.appendChild(popup);

          paragraphInput.replaceWith(container);
          setupParagraphButtonEvents(btn, popup, originalInput, newNode);
        }
      }

      // 恢復項目列表
      const itemsContainer = newNode.element.querySelector('.items');
      if (itemsContainer && nodeData.items) {
        itemsContainer.innerHTML = '';
        newNode.outputs = [];

        nodeData.items.forEach((itemText, index) => {
          const newItem = document.createElement('div');
          newItem.className = 'item';
          newItem.innerHTML = `
        <span class="drag-handle">☰</span>
        <input type="text" class="item-text" value="${escapeHtml(itemText || '項目 ' + (index + 1))}">
        <button class="add-node-btn">+</button>
        <div class="output-port" data-type="output"></div>
      `;
          itemsContainer.appendChild(newItem);

          newNode.outputs.push(index);
          setupAddNodeButton(newItem, newNode, index, container);
          setupOutputPort(newItem, newNode, index, container);
          setupItemDragAndDrop(newNode.element, newNode);
        });
      }
    }

    // 初始化小地圖
    function initMinimap() {
      minimapCanvas.width = minimapCanvas.offsetWidth;
      minimapCanvas.height = minimapCanvas.offsetHeight;
      updateMinimap();
    }

    // 更新小地圖
    function updateMinimap() {
      if (!nodes.length) return;

      // 計算所有節點的邊界
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      nodes.forEach(node => {
        const width = node.isFrame ? parseFloat(node.element.style.width || node.element.offsetWidth) : 200;
        const height = getNodeHeight(node.element);
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x + width);
        maxY = Math.max(maxY, node.y + height);
        console.log(`Node ${node.id}: x=${node.x}, y=${node.y}, width=${width}, height=${height}, isFrame=${node.isFrame}`);
      });

      // 添加邊距
      const padding = 50;
      minX -= padding;
      minY -= padding;
      maxX += padding;
      maxY += padding;

      // 計算縮放比例
      const width = maxX - minX;
      const height = maxY - minY;
      const scaleX = minimapCanvas.width / width;
      const scaleY = minimapCanvas.height / height;
      const minimapScale = Math.min(scaleX, scaleY);
      console.log(`Minimap bounds: minX=${minX}, minY=${minY}, maxX=${maxX}, maxY=${maxY}, minimapScale=${minimapScale}`);
      console.log(`Minimap canvas: width=${minimapCanvas.width}, height=${minimapCanvas.height}`);

      // 清空畫布
      minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

      // 繪製所有節點
      nodes.forEach(node => {
        const x = (node.x - minX) * minimapScale;
        const y = (node.y - minY) * minimapScale;
        const nodeWidth = (node.isFrame ? parseFloat(node.element.style.width || node.element.offsetWidth) : 200) * minimapScale;
        const nodeHeight = getNodeHeight(node.element) * minimapScale;
        console.log(`Node ${node.id} minimap: x=${x}, y=${y}, width=${nodeWidth}, height=${nodeHeight}`);

        // 使用不同顏色區分 frameNode 和普通節點
        minimapCtx.fillStyle = node.isFrame ? 'rgba(255, 255, 0, 0.3)' : 'rgba(255, 255, 255, 0.3)';
        minimapCtx.fillRect(x, y, nodeWidth, nodeHeight);
        minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        minimapCtx.lineWidth = 1;
        minimapCtx.strokeRect(x, y, nodeWidth, nodeHeight);
      });

      // 更新視口指示器
      updateViewportIndicator(minX, minY, minimapScale);
    }

    // 更新視口指示器
    function updateViewportIndicator(minX, minY, minimapScale) {
      /*
        // ===== 可調整參數區 =====
        const ADJUST_X = 0;       // X軸位置微調（正數向右，負數向左）
        const ADJUST_Y = 0;       // Y軸位置微調（正數向下，負數向上）
        const ZOOM_X = 1.0;       // X軸縮放倍數（1.0為原始大小）
        const ZOOM_Y = 1.0;       // Y軸縮放倍數（1.0為原始大小）
        const MOVE_MULTIPLIER_X = 1.0; // X軸移動倍數（影響鏡頭移動與指示器移動的比例）
        const MOVE_MULTIPLIER_Y = 1.0; // Y軸移動倍數（影響鏡頭移動與指示器移動的比例）
        // =======================
      */

      const ADJUST_X = 800;       // X軸位置微調（正數向右，負數向左）
      const ADJUST_Y = -0;       // Y軸位置微調（正數向下，負數向上）
      const ZOOM_X = 1.2;       // X軸縮放倍數（1.0為原始大小）
      const ZOOM_Y = 1.2;       // Y軸縮放倍數（1.0為原始大小）
      const MOVE_MULTIPLIER_X = 2.6; // X軸移動倍數（影響鏡頭移動與指示器移動的比例）
      const MOVE_MULTIPLIER_Y = 2.6; // Y軸移動倍數（影響鏡頭移動與指示器移動的比例）
      const leftPanelWidth = 321; // 左側工具列寬度

      // 1. 計算視口在世界坐標中的範圍（加入縮放倍數）
      const viewportCanvasWidth = (window.innerWidth - leftPanelWidth) * ZOOM_X;
      const viewportCanvasHeight = window.innerHeight * ZOOM_Y;
      const viewportWorldWidth = viewportCanvasWidth / scale;
      const viewportWorldHeight = viewportCanvasHeight / scale;

      // 2. 計算視口左上角的世界坐標（加入位置微調和移動倍數）
      const viewportWorldLeft = (-translateX * MOVE_MULTIPLIER_X - leftPanelWidth + ADJUST_X) / scale;
      const viewportWorldTop = (-translateY * MOVE_MULTIPLIER_Y + ADJUST_Y) / scale;

      // 3. 轉換到 minimap 坐標
      const indicatorLeft = (viewportWorldLeft - minX) * minimapScale;
      const indicatorTop = (viewportWorldTop - minY) * minimapScale;
      const indicatorWidth = viewportWorldWidth * minimapScale;
      const indicatorHeight = viewportWorldHeight * minimapScale;

      // 4. 限制邊界
      const boundedLeft = Math.max(0, Math.min(indicatorLeft, minimapCanvas.width - indicatorWidth));
      const boundedTop = Math.max(0, Math.min(indicatorTop, minimapCanvas.height - indicatorHeight));

      // 5. 更新指示器
      viewportIndicator.style.left = `${boundedLeft}px`;
      viewportIndicator.style.top = `${boundedTop}px`;
      viewportIndicator.style.width = `${indicatorWidth}px`;
      viewportIndicator.style.height = `${indicatorHeight}px`;
    }

    // 搜尋函數
    function searchNodesByName() {
      const searchTerm = document.getElementById('node-search-input').value.trim().toLowerCase();
      if (!searchTerm) return;

      // 清除之前的高亮
      nodes.forEach(node => {
        node.element.classList.remove('highlight-found');
      });

      // 找到匹配的節點
      const matchedNodes = nodes.filter(node => {
        const titleElement = node.element.querySelector('.node-title');
        return titleElement &&
          (titleElement.value || titleElement.textContent || titleElement.innerText)
            .toLowerCase()
            .includes(searchTerm);
      });

      if (matchedNodes.length > 0) {
        const targetNode = matchedNodes[0];
        targetNode.element.classList.add('highlight-found');

        // 獲取節點中心在螢幕座標
        const nodeRect = targetNode.element.getBoundingClientRect();
        const nodeCenterX = nodeRect.left + nodeRect.width / 2;
        const nodeCenterY = nodeRect.top + nodeRect.height / 2;

        // 轉換為世界座標
        const targetWorldX = (nodeCenterX - translateX) / scale;
        const targetWorldY = (nodeCenterY - translateY) / scale;

        // 取消正在進行的動畫
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }

        // 平滑移動到目標位置
        smoothMoveTo(targetWorldX, targetWorldY, scale, 800);
      } else {
        alert('未找到匹配的節點標題');
      }
    }

    // 平滑移動視圖
    // 優化：平滑移動函數（添加標題聚焦邏輯）
    // 優化的平滑移動函數
    function smoothMoveTo(targetWorldX, targetWorldY, targetScale, duration = 800) {
      const startTime = performance.now();
      const startX = translateX;
      const startY = translateY;
      const startScale = scale;

      // 計算目標平移值，使世界座標點位於視圖中心
      const targetTranslateX = (window.innerWidth / 2) - (targetWorldX * targetScale);
      const targetTranslateY = (window.innerHeight / 2) - (targetWorldY * targetScale);

      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = easeInOutCubic(progress);

        // 插值平移和縮放
        translateX = startX + (targetTranslateX - startX) * easeProgress;
        translateY = startY + (targetTranslateY - startY) * easeProgress;
        scale = startScale + (targetScale - startScale) * easeProgress;

        applyTransform();

        if (progress < 1) {
          animationFrameId = requestAnimationFrame(animate);
        } else {
          // 確保最終位置精確
          translateX = targetTranslateX + left - panel.width;
          translateY = targetTranslateY;
          scale = targetScale;
          applyTransform();

          // 添加高亮動畫
          const title = document.querySelector('.node.highlight-found .node-title');
          if (title) {
            title.classList.add('title-highlight');
            setTimeout(() => title.classList.remove('title-highlight'), 1000);
          }

          // 清除動畫 ID
          animationFrameId = null;
        }
      }

      animationFrameId = requestAnimationFrame(animate);
    }



    // 緩動函數
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }


    function arrangePopups() {
      const popups = Array.from(ALL_ACTIVE_POPUPS);
      if (popups.length === 0) return;

      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const margin = 10;

      // 統一尺寸配置
      const uniformSize = {
        small: { width: Math.min(350, screenWidth * 0.4), height: Math.min(250, screenHeight * 0.35) },
        medium: { width: Math.min(400, screenWidth * 0.5), height: Math.min(300, screenHeight * 0.45) }
      };


      // 在CSS樣式中添加高亮樣式
      const style = document.createElement('style');
      style.textContent = `
.node.highlight-found {
  box-shadow: 0 0 15px 5px rgba(0, 255, 255, 0.7) !important;
  transition: box-shadow 0.3s;
}
`;
      document.head.appendChild(style);

      // 1. 設置彈窗尺寸
      popups.forEach((popup, index) => {
        if (index >= 5) { // 第6個開始
          popup.style.width = `${uniformSize.small.width}px`;
          popup.style.height = `${uniformSize.small.height}px`;
        } else if (index >= 3) { // 第4-5個
          popup.style.width = `${uniformSize.medium.width}px`;
          popup.style.height = `${uniformSize.medium.height}px`;
        } else { // 前3個
          popup.style.maxWidth = `${screenWidth * 0.8}px`;
          popup.style.maxHeight = `${screenHeight * 0.8}px`;
          popup.style.width = '';
          popup.style.height = '';
        }
        popup.style.display = 'block';
      });

      // 2. 處理1-3個彈窗（寬度自適應）
      if (popups.length <= 3) {
        const firstThree = popups.slice(0, 3);
        adjustWidths(firstThree, margin, screenWidth);
        arrangeGridLayout(firstThree, margin, screenWidth, screenHeight);
        return;
      }

      // 排列前3個（帶寬度自適應）
      const firstThree = popups.slice(0, 3);
      adjustWidths(firstThree, margin, screenWidth);
      arrangeGridLayout(firstThree, margin, screenWidth, screenHeight);

      // 3. 處理第4-5個彈窗（新增高度居中邏輯）
      if (popups.length >= 4) {
        // 計算各列高度
        const colHeights = firstThree.map(popup =>
          parseFloat(popup.style.top) + popup.getBoundingClientRect().height
        );

        // 找出最短和中間高度的列
        const sortedIndices = [...colHeights]
          .map((h, i) => ({ h, i }))
          .sort((a, b) => a.h - b.h)
          .map(obj => obj.i);

        const shortestCol = sortedIndices[0];
        const middleCol = sortedIndices[1];

        // 放置第4個在最短列下方
        const fourthPopup = popups[3];
        const fourthRect = fourthPopup.getBoundingClientRect();
        let fourthY = colHeights[shortestCol] + margin;

        // 放置第5個在中間高度列下方
        const fifthPopup = popups.length >= 5 ? popups[4] : null;
        const fifthRect = fifthPopup?.getBoundingClientRect();
        let fifthY = colHeights[middleCol] + margin;

        // 計算整體高度
        const totalHeight = Math.max(
          fourthY + fourthRect.height,
          fifthY + (fifthRect?.height || 0)
        );

        // 嘗試垂直居中
        const centerOffset = Math.max(0, (screenHeight - totalHeight) / 2);

        if (centerOffset > 0) {
          // 有足夠空間居中
          firstThree.forEach(popup => {
            popup.style.top = `${parseFloat(popup.style.top) + centerOffset}px`;
          });

          fourthPopup.style.left = `${parseFloat(firstThree[shortestCol].style.left)}px`;
          fourthPopup.style.top = `${fourthY + centerOffset}px`;

          if (fifthPopup) {
            fifthPopup.style.left = `${parseFloat(firstThree[middleCol].style.left)}px`;
            fifthPopup.style.top = `${fifthY + centerOffset}px`;
          }
        } else {
          // 需要縮放高度
          const scaleFactor = screenHeight / totalHeight;

          // 調整前3個高度
          firstThree.forEach(popup => {
            const rect = popup.getBoundingClientRect();
            popup.style.height = `${rect.height * scaleFactor * 0.9}px`; // 保留10%邊距
          });

          // 重新計算位置
          arrangeGridLayout(firstThree, margin, screenWidth, screenHeight);
          const newColHeights = firstThree.map(popup =>
            parseFloat(popup.style.top) + popup.getBoundingClientRect().height
          );

          // 重新放置第4-5個
          fourthPopup.style.left = `${parseFloat(firstThree[shortestCol].style.left)}px`;
          fourthPopup.style.top = `${newColHeights[shortestCol] + margin}px`;

          if (fifthPopup) {
            fifthPopup.style.left = `${parseFloat(firstThree[middleCol].style.left)}px`;
            fifthPopup.style.top = `${newColHeights[middleCol] + margin}px`;
          }
        }
      }

      // 4. 處理第6+個彈窗（左上角網格排列）
      if (popups.length >= 6) {
        let currentX = margin;
        let currentY = margin;
        let rowHeight = 0;

        for (let i = 5; i < popups.length; i++) {
          const popup = popups[i];
          const rect = popup.getBoundingClientRect();

          // 換行檢查
          if (currentX + rect.width > screenWidth) {
            currentX = margin;
            currentY += rowHeight + margin;
            rowHeight = 0;
          }

          // 設置位置
          popup.style.left = `${currentX}px`;
          popup.style.top = `${currentY}px`;

          // 更新參數
          currentX += rect.width + margin;
          rowHeight = Math.max(rowHeight, rect.height);

          // 超出屏幕底部處理
          if (currentY + rect.height > screenHeight) {
            currentX = margin;
            currentY = margin;
          }
        }
      }
    }

    // 寬度自適應輔助函數
    function adjustWidths(popups, margin, screenWidth) {
      let totalWidth = 0;
      const originalWidths = [];

      popups.forEach(popup => {
        popup.style.width = '';
        const rect = popup.getBoundingClientRect();
        originalWidths.push(rect.width);
        totalWidth += rect.width;
      });

      totalWidth += margin * (popups.length - 1);

      if (totalWidth > screenWidth) {
        const scaleFactor = (screenWidth - margin * (popups.length - 1)) /
          (totalWidth - margin * (popups.length - 1));

        popups.forEach((popup, i) => {
          popup.style.width = `${originalWidths[i] * scaleFactor}px`;
        });
      }
    }
    // 原有的網格佈局函數
    function arrangeGridLayout(popups, margin, screenWidth, screenHeight) {
      if (popups.length === 0) return;

      // 計算所有彈出框的總面積和平均寬高
      let totalWidth = 0;
      let totalHeight = 0;
      popups.forEach(popup => {
        const rect = popup.getBoundingClientRect();
        totalWidth += rect.width + margin;
        totalHeight += rect.height + margin;
      });

      // 計算最接近正方形的行列分佈
      const aspectRatio = screenWidth / screenHeight;
      let cols = Math.ceil(Math.sqrt(popups.length * aspectRatio));
      let rows = Math.ceil(popups.length / cols);

      // 調整行列數以更貼近正方形
      while (rows > cols && (rows - 1) * cols >= popups.length) {
        rows--;
        cols = Math.ceil(popups.length / rows);
      }

      // 計算每行列的最大寬高
      const colWidths = new Array(cols).fill(0);
      const rowHeights = new Array(rows).fill(0);
      popups.forEach((popup, index) => {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const rect = popup.getBoundingClientRect();
        colWidths[col] = Math.max(colWidths[col], rect.width);
        rowHeights[row] = Math.max(rowHeights[row], rect.height);
      });

      // 計算總佈局寬高
      const layoutWidth = colWidths.reduce((sum, width) => sum + width + margin, -margin);
      const layoutHeight = rowHeights.reduce((sum, height) => sum + height + margin, -margin);

      // 計算起始位置（居中）
      const startX = (screenWidth - layoutWidth) / 2;
      const startY = (screenHeight - layoutHeight) / 2;

      // 設置每個彈出框的位置
      const colPositions = [];
      let currentX = startX;
      for (let i = 0; i < cols; i++) {
        colPositions.push(currentX);
        currentX += colWidths[i] + margin;
      }

      const rowPositions = [];
      let currentY = startY;
      for (let i = 0; i < rows; i++) {
        rowPositions.push(currentY);
        currentY += rowHeights[i] + margin;
      }

      popups.forEach((popup, index) => {
        const col = index % cols;
        const row = Math.floor(index / cols);
        const rect = popup.getBoundingClientRect();

        popup.style.left = `${colPositions[col]}px`;
        popup.style.top = `${rowPositions[row]}px`;
        popup.style.width = `${rect.width}px`;
        popup.style.height = `${rect.height}px`;
      });
    }

    function setupParagraphButtonEvents(btn, popup, paragraphInput, nodeData) {
      // 檢查必要的DOM元素是否存在
      if (!btn || !btn.parentNode || !popup) {
        console.error('無法設置按鈕事件：缺少必要的DOM元素');
        return;
      }

      // 先克隆原始按鈕（保留原始按鈕不變）
      const btnClone = btn.cloneNode(true);

      // 創建按鈕容器
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.alignItems = 'center';
      buttonContainer.style.marginBottom = '10px';

      // 創建並添加COPY和UPDATE按鈕
      const copyBtn = createCopyButton();
      const updateBtn = createUpdateButton();

      // 先將克隆按鈕和更新按鈕添加到容器
      buttonContainer.appendChild(btnClone);
      buttonContainer.appendChild(updateBtn);

      // 小地圖點擊事件
      minimapCanvas.addEventListener('click', (e) => {
        const rect = minimapCanvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        // 計算所有節點的邊界（與updateMinimap相同）
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        nodes.forEach(node => {
          minX = Math.min(minX, node.x);
          minY = Math.min(minY, node.y);
          maxX = Math.max(maxX, node.x + 200);
          maxY = Math.max(maxY, node.y + getNodeHeight(node.element));
        });

        const padding = 50;
        minX -= padding;
        minY -= padding;
        maxX += padding;
        maxY += padding;

        const width = maxX - minX;
        const height = maxY - minY;
        const scaleX = minimapCanvas.width / width;
        const scaleY = minimapCanvas.height / height;
        const scale = Math.min(scaleX, scaleY);

        // 計算點擊位置對應的世界座標
        const worldX = (clickX / scale) + minX;
        const worldY = (clickY / scale) + minY;

        // 移動視圖到點擊位置
        smoothMoveTo(worldX, worldY, this.scale, 300);
      });

      // 替換原始按鈕
      try {
        btn.parentNode.replaceChild(buttonContainer, btn);
      } catch (error) {
        console.error('替換按鈕失敗:', error);
        return;
      }

      // 保存原始位置信息
      const { originalParent, originalNextSibling, originalStyles } = saveOriginalPopupPosition(popup);

      // 設置按鈕事件
      setupCopyButtonEvents(copyBtn, popup);
      setupUpdateButtonEvents(updateBtn, popup, nodeData);
      popup.appendChild(copyBtn);

      // 設置彈出框切換事件
      setupPopupToggleEvents(btnClone, popup, nodeData);

      // 設置全局事件處理器
      const handleClickOutside = createClickOutsideHandler(popup, originalParent, originalNextSibling, originalStyles, nodeData);
      const clearHandler = createClearHandler(popup, paragraphInput, nodeData);

      document.addEventListener('click', handleClickOutside);
      document.addEventListener('keydown', clearHandler);

      // 儲存事件處理器以便清理
      popup.dataset.eventHandlers = JSON.stringify({
        click: handleClickOutside,
        keydown: clearHandler
      });

      setupPopupCleanup(popup, handleClickOutside, clearHandler);

      return btnClone;
    }



    // 修改後的 createButtonContainer 函數
    function createButtonContainer(originalBtn) {
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.alignItems = 'center';
      buttonContainer.style.marginBottom = '10px';

      // 不再克隆按鈕，只是創建容器
      return {
        buttonContainer,
        newBtn: originalBtn // 直接使用原始按鈕
      };
    }


    // 創建按鈕容器
    function createButtonContainer(btn) {
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.alignItems = 'center';
      buttonContainer.style.marginBottom = '10px';

      return {
        buttonContainer,
        newBtn: btn.cloneNode(true) // 克隆原始按鈕
      };
    }

    // 創建COPY按鈕
    function createCopyButton() {
      const copyBtn = document.createElement('button');
      copyBtn.className = 'copy-btn';
      copyBtn.textContent = '';
      return copyBtn;
    }

    // 創建UPDATE按鈕
    function createUpdateButton() {
      const updateBtn = document.createElement('button');
      updateBtn.className = 'update-btn';
      updateBtn.textContent = '更新';
      updateBtn.title = '更新內容並調整連接';
      return updateBtn;
    }

    // 設置COPY按鈕事件
    function setupCopyButtonEvents(copyBtn, popup) {
      copyBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleCopyText(popup.textContent, copyBtn);
      });
    }

    // 處理複製文本
    function handleCopyText(text, copyBtn) {
      try {
        navigator.clipboard.writeText(text)
          .then(() => {
            updateButtonTextTemporarily(copyBtn, '已複製!');
          })
          .catch(err => {
            console.error('複製失敗:', err);
            updateButtonTextTemporarily(copyBtn, '複製失敗');
          });
      } catch (err) {
        console.error('複製失敗:', err);
        updateButtonTextTemporarily(copyBtn, '複製失敗');
      }
    }

    // 暫時更新按鈕文本
    function updateButtonTextTemporarily(button, text) {
      button.textContent = text;
      setTimeout(() => {
        button.textContent = '';
      }, 2000);
    }

    // 設置UPDATE按鈕事件
    function setupUpdateButtonEvents(updateBtn, popup, nodeData) {
      updateBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showUpdateDialog(popup.textContent, (newContent) => {
          if (newContent !== null) {
            updateNodeContent(nodeData, newContent);
          }
        });
      });
    }

    // 保存彈出框原始位置
    function saveOriginalPopupPosition(popup) {
      return {
        originalParent: popup.parentNode,
        originalNextSibling: popup.nextSibling,
        originalStyles: {
          position: popup.style.position,
          left: popup.style.left,
          top: popup.style.top,
          zIndex: popup.style.zIndex
        }
      };
    }

    // 設置彈出框切換事件
    function setupPopupToggleEvents(button, popup, nodeData) {
      button.addEventListener('click', (e) => {
        // 移除現有的彈出框（如果存在）
        if (nodeData.popupContainer) {
          nodeData.popupContainer.remove();
          nodeData.popupContainer = null;
        }

        // 創建新的彈出框容器
        const popupContainer = document.createElement('div');
        popupContainer.style.position = 'fixed';
        popupContainer.style.zIndex = '2147483647';

        // 克隆彈出框內容以避免DOM重複問題
        const popupClone = popup.cloneNode(true);
        popupClone.style.display = 'block';
        popupClone.style.width = '100%';
        popupClone.style.height = '100%';
        popupClone.style.overflow = 'auto';
        popupContainer.appendChild(popupClone);

        document.body.appendChild(popupContainer);
        nodeData.popupContainer = popupContainer;

        // 更新ALL_ACTIVE_POPUPS
        ALL_ACTIVE_POPUPS.add(popupClone);
        activePopup = popupClone;

        // 排列彈出框
        arrangePopups();

        e.stopPropagation();
      });
    }

    // 創建點擊外部處理器
    function createClickOutsideHandler(popup, originalParent, originalNextSibling, originalStyles, nodeData) {
      return (e) => {
        const isClickInsideAnyPopup = Array.from(ALL_ACTIVE_POPUPS).some(p => p.contains(e.target));
        const isClickInsideButton = nodeData.element.contains(e.target);

        if (!isClickInsideAnyPopup && !isClickInsideButton) {
          closeAllPopups(popup, originalParent, originalNextSibling, originalStyles, nodeData);
        }
      };
    }

    // 關閉所有彈窗
    function closeAllPopups(popup, originalParent, originalNextSibling, originalStyles, nodeData) {
      ALL_ACTIVE_POPUPS.forEach(p => {
        p.style.display = 'none';
        restoreOriginalPosition(p, originalParent, originalNextSibling, originalStyles);
        if (p.parentNode) {
          p.parentNode.removeChild(p);
        }
      });
      ALL_ACTIVE_POPUPS.clear();
      activePopup = null;

      // 清理nodeData中的popupContainer
      if (nodeData.popupContainer) {
        nodeData.popupContainer.remove();
        nodeData.popupContainer = null;
      }
    }

    // 恢復原始位置
    function restoreOriginalPosition(popup, originalParent, originalNextSibling, originalStyles) {
      if (originalParent && popup.parentNode === document.body) {
        originalParent.insertBefore(popup, originalNextSibling);
      }
      Object.entries(originalStyles).forEach(([prop, value]) => {
        popup.style[prop] = value;
      });
    }

    // 創建清除處理器
    function createClearHandler(popup, paragraphInput, nodeData) {
      return (e) => {
        if (e.key.toLowerCase() === 'x' && activePopup === popup) {
          clearParagraphInput(paragraphInput, nodeData, popup);
          e.preventDefault();
        }
      };
    }

    // 清除段落輸入
    function clearParagraphInput(paragraphInput, nodeData, popup) {
      paragraphInput.value = '';
      resetItemsList(nodeData);
      popup.style.display = 'none';
      ALL_ACTIVE_POPUPS.delete(popup);
      activePopup = null;
    }

    // 設置彈出框清理
    function setupPopupCleanup(popup, clickHandler, keyHandler) {
      popup.addEventListener('DOMNodeRemoved', () => {
        document.removeEventListener('click', clickHandler);
        document.removeEventListener('keydown', keyHandler);
        ALL_ACTIVE_POPUPS.delete(popup);
      });
    }

    // 新增顯示更新對話框的函數
    function showUpdateDialog(currentContent, callback) {
      // 創建對話框元素
      const dialog = document.createElement('div');
      dialog.className = 'update-dialog';

      // 對話框內容
      dialog.innerHTML = `
    <div class="update-dialog-content">
      <textarea id="update-dialog-textarea">${escapeHtml(currentContent)}</textarea>
      <div class="update-dialog-buttons">
        <button class="update-dialog-cancel">取消</button>
        <button class="update-dialog-confirm">確認</button>
      </div>
    </div>
  `;

      // 添加到body
      document.body.appendChild(dialog);

      // 獲取元素引用
      const textarea = dialog.querySelector('#update-dialog-textarea');
      const cancelBtn = dialog.querySelector('.update-dialog-cancel');
      const confirmBtn = dialog.querySelector('.update-dialog-confirm');

      // 聚焦到textarea
      textarea.focus();

      // 取消按鈕點擊事件
      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(dialog);
        callback(null);
      });

      // 確認按鈕點擊事件
      confirmBtn.addEventListener('click', () => {
        const newContent = textarea.value.trim();
        document.body.removeChild(dialog);
        callback(newContent);
      });

      // 按ESC鍵關閉對話框
      dialog.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          document.body.removeChild(dialog);
          callback(null);
        }
      });
    }


    function updateNodeContent(nodeData, newContent) {
      const element = nodeData.element;

      console.log('=== 開始更新節點內容 ===');
      console.log('節點:', nodeData.element.querySelector('.node-title').value);
      console.log('新內容長度:', newContent.length);

      // 1. 更新內容顯示
      const popup = element.querySelector('.paragraph-popup');
      const btn = element.querySelector('.paragraph-btn');
      popup.textContent = newContent;
      btn.textContent = newContent.length > 50
        ? newContent.substring(0, 47) + '...'
        : newContent;
      btn.dataset.originalContent = newContent;

      // 2. 提取函數信息
      const newFunctionName = extractFunctionName(newContent);
      if (newFunctionName) {
        element.querySelector('.node-title').value = newFunctionName;
        updateSameNameHighlights();
      }

      // 3. 獲取新舊函數列表（應用黑名單過濾）
      const newCalledFunctions = extractCalledFunctions(newContent, newFunctionName);
      console.log('新找到的函數:', newCalledFunctions);

      // 應用黑名單過濾
      const filteredNewFunctions = newCalledFunctions.filter(funcName => {
        const isBlacklisted = currentLanguage === 'python'
          ? PYTHON_FUNCTION_BLACKLIST.includes(funcName)
          : FUNCTION_BLACKLIST.includes(funcName);

        if (isBlacklisted) {
          console.log(`過濾黑名單函數: "${funcName}"`);
        }
        return !isBlacklisted;
      });

      console.log('過濾後的函數:', filteredNewFunctions);

      // 4. 獲取舊項目（用於連接恢復）
      const oldItems = Array.from(element.querySelectorAll('.item-text')).map(item => item.value);
      console.log('舊項目:', oldItems);

      // 5. 建立精確連接映射表（使用位置+名稱作為鍵）
      const connectionMap = new Map();
      connections.forEach(conn => {
        if (conn.fromNode === nodeData.id) {
          const itemName = oldItems[conn.fromOutput];
          connectionMap.set(`${conn.fromOutput}_${itemName}`, {
            toNode: conn.toNode,
            toInput: conn.toInput
          });
        }
      });

      console.log('連接映射:', connectionMap);

      // 6. 完全清除舊連接
      connections = connections.filter(conn => conn.fromNode !== nodeData.id);

      // 7. 重建項目列表（只使用過濾後的函數）
      const itemsContainer = element.querySelector('.items');
      itemsContainer.innerHTML = '';
      nodeData.outputs = [];

      console.log('開始重建項目列表，數量:', filteredNewFunctions.length);

      // 8. 智能重建項目和連接
      filteredNewFunctions.forEach((newFunc, newIndex) => {
        // 創建新項目
        const itemDiv = document.createElement('div');
        itemDiv.className = 'item';
        itemDiv.innerHTML = `
      <span class="drag-handle">☰</span>
      <input type="text" class="item-text" value="${escapeHtml(newFunc)}">
      <button class="add-node-btn">+</button>
      <div class="output-port" data-type="output"></div>
    `;
        itemsContainer.appendChild(itemDiv);
        nodeData.outputs.push(newIndex);

        // 設置交互
        setupAddNodeButton(itemDiv, nodeData, newIndex, container);
        setupOutputPort(itemDiv, nodeData, newIndex, container);
        setupItemDragAndDrop(element, nodeData);

        // 恢復連接的智能邏輯
        let connectionRestored = false;

        // 情況1：完全匹配原位置和名稱
        const exactKey = `${newIndex}_${newFunc}`;
        if (connectionMap.has(exactKey)) {
          const { toNode, toInput } = connectionMap.get(exactKey);
          connections.push({
            fromNode: nodeData.id,
            fromOutput: newIndex,
            toNode,
            toInput
          });
          connectionRestored = true;
          console.log(`✅ 恢復連接: ${exactKey}`);
        }

        // 情況2：名稱匹配但位置變化（防止因插入新項目導致錯誤連接）
        if (!connectionRestored) {
          for (const [key, connData] of connectionMap) {
            const [oldIndex, oldFunc] = key.split('_');
            if (oldFunc === newFunc) {
              // 確保這是第一個匹配的且未被使用的連接
              if (!connections.some(c =>
                c.fromNode === nodeData.id &&
                c.toNode === connData.toNode &&
                c.toInput === connData.toInput
              )) {
                connections.push({
                  fromNode: nodeData.id,
                  fromOutput: newIndex,
                  toNode: connData.toNode,
                  toInput: connData.toInput
                });
                connectionMap.delete(key); // 防止重複使用
                console.log(`✅ 名稱匹配恢復連接: ${key} -> ${newIndex}`);
                break;
              }
            }
          }
        }
      });

      // 9. 更新變數分析按鈕
      analyzeVariables(nodeData);

      // 10. 最終處理
      drawConnections();

      console.log('更新完成，新連接數量:', connections.filter(conn => conn.fromNode === nodeData.id).length);
      showStatusMessage('內容已更新，連接精確保持，已過濾黑名單函數', 'success');
    }

    // 初始化畫布大小
    function resizeCanvas() {
      canvas.width = container.offsetWidth;
      canvas.height = container.offsetHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // 視圖轉換函數
    function toWorldX(screenX) {
      return (screenX / scale) + translateX;
    }

    function toWorldY(screenY) {
      return (screenY / scale) + translateY;
    }

    // 提取到外部的工具函數
    // 修改 extractFunctionName 函數以支持 Python
    function extractFunctionName(content) {
      if (currentLanguage === 'python') {
        const pythonMatch = content.match(/def\s+([a-zA-Z_][0-9a-zA-Z_]*)\s*\(/);
        return pythonMatch ? pythonMatch[1] : null;
      } else {
        const functionNameMatch = content.match(/function\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/);
        return functionNameMatch ? functionNameMatch[1] : null;
      }
    }

    function extractCalledFunctions(content, functionNameToExclude) {
      const functionNames = new Set();

      console.log('提取被調用函數，排除:', functionNameToExclude);

      if (currentLanguage === 'python') {
        // Python 變數提取（保持原有邏輯）
        const pythonCallRegex = /([a-zA-Z_][0-9a-zA-Z_]*)\s*\([^)]*\)/g;
        let match;

        while ((match = pythonCallRegex.exec(content)) !== null) {
          const calledFunctionName = match[1];
          const isBlacklisted = PYTHON_FUNCTION_BLACKLIST.includes(calledFunctionName);

          // 新增：過濾只含有 "(e" 的項目
          if (calledFunctionName.trim() === '(e') {
            console.log(`❌ 過濾只含有 "(e" 的函數: "${calledFunctionName}"`);
            continue;
          }

          if (!isBlacklisted && calledFunctionName !== functionNameToExclude) {
            functionNames.add(calledFunctionName);
            console.log(`✅ 包含函數: "${calledFunctionName}"`);
          } else if (isBlacklisted) {
            console.log(`❌ 排除黑名單函數: "${calledFunctionName}"`);
          }
        }
      } else {
        // JavaScript 變數提取 - 原有邏輯
        const functionCallRegex = /([a-zA-Z_$][0-9a-zA-Z_$]*)\s*\([^)]*\)/g;
        let match;

        while ((match = functionCallRegex.exec(content)) !== null) {
          const calledFunctionName = match[1];
          const isBlacklisted = FUNCTION_BLACKLIST.includes(calledFunctionName);

          // 新增：過濾只含有 "(e" 的項目
          if (calledFunctionName.trim() === '(e') {
            console.log(`❌ 過濾只含有 "(e" 的函數: "${calledFunctionName}"`);
            continue;
          }

          if (!isBlacklisted && calledFunctionName !== functionNameToExclude) {
            functionNames.add(calledFunctionName);
            console.log(`✅ 包含函數: "${calledFunctionName}"`);
          } else if (isBlacklisted) {
            console.log(`❌ 排除黑名單函數: "${calledFunctionName}"`);
          }
        }

        // 新增：提取事件監聽器格式的函數名稱
        const additionalNames = extractAdditionalFunctionNames(content);
        additionalNames.forEach(name => {
          // 新增：過濾只含有 "(e" 的項目
          if (name.trim() === '(e') {
            console.log(`❌ 過濾只含有 "(e" 的額外函數: "${name}"`);
            return;
          }

          if (name !== functionNameToExclude) {
            functionNames.add(name);
          }
        });
      }

      console.log('最終提取的函數:', Array.from(functionNames));
      return Array.from(functionNames);
    }

    // 添加 Python 黑名單
    const PYTHON_FUNCTION_BLACKLIST = [
      // 內建函數
      // === 內建函數 ===
      'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes',
      'callable', 'chr', 'classmethod', 'compile', 'complex',
      'delattr', 'dict', 'dir', 'divmod',
      'enumerate', 'eval', 'exec',
      'filter', 'float', 'format', 'frozenset',
      'getattr', 'globals',
      'hasattr', 'hash', 'help', 'hex',
      'id', 'input', 'int', 'isinstance', 'issubclass', 'iter',
      'len', 'list', 'locals',
      'map', 'max', 'memoryview', 'min',
      'next', 'object', 'oct', 'open', 'ord',
      'pow', 'print', 'property',
      'range', 'repr', 'reversed', 'round',
      'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super',
      'tuple', 'type',
      'vars', 'zip',

      // === 危險函數（可繞過限制）===
      '__import__', '__build_class__', '__loader__', '__spec__',

      // === 關鍵字（語法禁止）===
      'and', 'as', 'assert', 'async', 'await',
      'break',
      'class', 'continue',
      'def', 'del',
      'elif', 'else', 'except',
      'False', 'finally', 'for', 'from',
      'global',
      'if', 'import', 'in', 'is',
      'lambda',
      'None', 'nonlocal', 'not',
      'or',
      'pass', 'raise', 'return',
      'True', 'try',
      'while', 'with',
      'yield',

      // === 常用方法（字串、列表、字典等）===
      'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort',
      'capitalize', 'casefold', 'center', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map',
      'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric',
      'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans',
      'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split',
      'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill',
      'get', 'items', 'keys', 'popitem', 'setdefault', 'update', 'values',

      // === 其他可能危險的方法 ===
      '__globals__', '__code__', '__class__', '__subclasses__', '__bases__', '__getattribute__',
    ]
    // HTML轉義輔助函數
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // 顯示狀態消息函數
    function showStatusMessage(message, type = 'info') {
      const msg = document.createElement('div');
      msg.textContent = message;
      msg.style.position = 'fixed';
      msg.style.bottom = '20px';
      msg.style.right = '20px';
      msg.style.padding = '10px 20px';
      msg.style.background = type === 'error' ? '#ff4444' : '#4CAF50';
      msg.style.color = 'white';
      msg.style.borderRadius = '4px';
      msg.style.zIndex = '10000';

      document.body.appendChild(msg);

      setTimeout(() => {
        msg.style.transition = 'opacity 0.5s';
        msg.style.opacity = '0';
        setTimeout(() => msg.remove(), 500);
      }, 3000);
    }

    // 改進的函數提取邏輯 - 使用遞歸大括號匹配
    function extractFunctions(code) {
      console.log('開始提取函數，代碼長度:', code.length);
      const functions = {};

      // 主要函數匹配模式
      const mainPattern = /function\s+([a-zA-Z_$][0-9a-zA-Z_$]*)\s*\([^)]*\)\s*\{/g;
      let match;
      let count = 0;

      while ((match = mainPattern.exec(code)) !== null) {
        const funcName = match[1];
        const startPos = match.index;
        const bracePos = code.indexOf('{', startPos);

        if (bracePos !== -1) {
          const funcBody = extractBalancedBraces(code, bracePos);
          if (funcBody) {
            functions[funcName] = {
              code: code.substring(startPos, startPos + match[0].length + funcBody.length),
              start: startPos,
              end: startPos + match[0].length + funcBody.length
            };
            count++;

            // 特別記錄 closeAllLists
            if (funcName === 'closeAllLists') {
              console.log('✅ 提取到 closeAllLists 函數');
            }
          }
        }
      }

      console.log(`總共提取 ${count} 個函數`);

      // 如果沒有找到 closeAllLists，嘗試搜索整個文件
      if (!functions.closeAllLists) {
        console.log('搜索 closeAllLists 文本...');
        const searchIndex = code.indexOf('closeAllLists');
        if (searchIndex !== -1) {
          console.log('找到 closeAllLists 文本，位置:', searchIndex);
          const context = code.substring(Math.max(0, searchIndex - 100), Math.min(code.length, searchIndex + 200));
          console.log('上下文:', context);
        }
      }

      return functions;
    }

    // 提取平衡的大括號內容
    function extractBalancedBraces(code, startPos) {
      let braceCount = 0;
      let i = startPos;

      for (; i < code.length; i++) {
        if (code[i] === '{') {
          braceCount++;
        } else if (code[i] === '}') {
          braceCount--;
          if (braceCount === 0) {
            return code.substring(startPos, i + 1);
          }
        }
      }

      return null; // 不平衡的大括號
    }


    // 提取平衡的大括號內容
    function setupAddNodeButton(itemElement, nodeData, outputIndex, container) {
      itemElement.querySelector('.add-node-btn').addEventListener('click', (e) => {
        const name = itemElement.querySelector('.item-text').value;
        const functionName = name.trim();

        console.log('=== 點擊 add-node-btn ===');
        console.log('請求的函數名:', functionName);
        console.log('當前加載的函數數量:', Object.keys(loadedHtmlFunctions).length);

        // 立即檢查是否存在該函數
        if (loadedHtmlFunctions[functionName]) {
          console.log('✅ 直接找到函數:', functionName);
        } else {
          console.log('❌ 未直接找到，嘗試模糊匹配...');
          // 模糊匹配
          const lowerName = functionName.toLowerCase();
          for (const key in loadedHtmlFunctions) {
            if (key.toLowerCase() === lowerName) {
              console.log('✅ 模糊匹配找到:', key);
              break;
            }
          }
        }

        if (functionContent) {
          console.log('找到的函數內容長度:', functionContent.length);
          console.log('內容預覽:', functionContent.substring(0, 200));
        } else {
          console.log('❌ 未找到函數內容，可能的原因:');
          console.log('1. 函數名不匹配');
          console.log('2. HTML文件未正確加載');
          console.log('3. 函數不在加載的文件中');

          // 顯示最接近的函數名
          const allFunctionNames = Object.keys(loadedHtmlFunctions);
          const similarNames = allFunctionNames.filter(name =>
            name.toLowerCase().includes(functionName.toLowerCase()) ||
            functionName.toLowerCase().includes(name.toLowerCase())
          );
          console.log('相似的函數名:', similarNames);
        }

        const childNodes = connections.filter(conn =>
          conn.fromNode === nodeData.id &&
          conn.fromOutput === outputIndex
        ).length;

        const baseX = nodeData.x + 200 / scale;
        const baseY = nodeData.y + (childNodes * 120 / scale);

        // 創建新節點，並傳入函數內容
        const newNode = createNode(
          baseX,
          baseY,
          functionName,
          'normal',
          functionContent
        );

        // 雙重保險：創建節點後再次檢查並填充內容
        if (functionContent) {
          setTimeout(() => {
            const paragraphInput = newNode.element.querySelector('.paragraph-input');
            if (paragraphInput) {
              console.log('最終檢查 - paragraphInput 值:', paragraphInput.value);
              if (paragraphInput.value !== functionContent) {
                console.log('執行強制填充');
                paragraphInput.value = functionContent;

                // 觸發輸入事件以自動分析變數和創建項目
                const inputEvent = new Event('input', { bubbles: true });
                paragraphInput.dispatchEvent(inputEvent);
              }
            }
          }, 100);

          showStatusMessage(`已自動填入函數 "${foundKey || functionName}" 的內容`, 'success');
        } else {
          showStatusMessage(`創建節點 "${functionName}"，但未找到對應函數內容`, 'warning');
        }

        connections.push({
          fromNode: nodeData.id,
          fromOutput: outputIndex,
          toNode: newNode.id
        });

        drawConnections();
        e.stopPropagation();
      });
    }


    function setupAddNodeButton(itemElement, nodeData, outputIndex, container) {
      itemElement.querySelector('.add-node-btn').addEventListener('click', (e) => {
        const name = itemElement.querySelector('.item-text').value;
        const functionName = name.trim();

        console.log('=== 詳細調試信息 ===');
        console.log('輸入的函數名:', functionName);
        console.log('loadedHtmlFunctions 類型:', typeof loadedHtmlFunctions);
        console.log('loadedHtmlFunctions 鍵數量:', Object.keys(loadedHtmlFunctions).length);
        console.log('所有可用的函數名:', Object.keys(loadedHtmlFunctions));

        // 詳細檢查函數匹配
        let functionContent = null;
        let foundKey = null;

        // 方法1：精確匹配
        if (loadedHtmlFunctions[functionName]) {
          functionContent = loadedHtmlFunctions[functionName].code;
          foundKey = functionName;
          console.log('✅ 精確匹配找到函數:', functionName);
        }
        // 方法2：模糊匹配（大小寫不敏感）
        else {
          const lowerCaseName = functionName.toLowerCase();
          for (const key in loadedHtmlFunctions) {
            if (key.toLowerCase() === lowerCaseName) {
              functionContent = loadedHtmlFunctions[key].code;
              foundKey = key;
              console.log('✅ 模糊匹配找到函數:', key, '對應請求:', functionName);
              break;
            }
          }
        }

        if (functionContent) {
          console.log('找到的函數內容長度:', functionContent.length);
          console.log('內容預覽:', functionContent.substring(0, 200));
        } else {
          console.log('❌ 未找到函數內容，可能的原因:');
          console.log('1. 函數名不匹配');
          console.log('2. HTML文件未正確加載');
          console.log('3. 函數不在加載的文件中');

          // 顯示最接近的函數名
          const allFunctionNames = Object.keys(loadedHtmlFunctions);
          const similarNames = allFunctionNames.filter(name =>
            name.toLowerCase().includes(functionName.toLowerCase()) ||
            functionName.toLowerCase().includes(name.toLowerCase())
          );
          console.log('相似的函數名:', similarNames);
        }

        const childNodes = connections.filter(conn =>
          conn.fromNode === nodeData.id &&
          conn.fromOutput === outputIndex
        ).length;

        const baseX = nodeData.x + 200 / scale;
        const baseY = nodeData.y + (childNodes * 120 / scale);

        // 創建新節點，並傳入函數內容
        const newNode = createNode(
          baseX,
          baseY,
          functionName,
          'normal',
          functionContent  // 傳入函數內容
        );

        // 雙重保險：創建節點後再次檢查並填充內容
        if (functionContent) {
          setTimeout(() => {
            const paragraphInput = newNode.element.querySelector('.paragraph-input');
            if (paragraphInput) {
              console.log('最終檢查 - paragraphInput 值:', paragraphInput.value);
              if (paragraphInput.value !== functionContent) {
                console.log('執行強制填充');
                paragraphInput.value = functionContent;

                // 觸發輸入事件以自動分析變數和創建項目
                const inputEvent = new Event('input', { bubbles: true });
                paragraphInput.dispatchEvent(inputEvent);
              }
            }
          }, 100);

          showStatusMessage(`已自動填入函數 "${foundKey || functionName}" 的內容`, 'success');
        } else {
          showStatusMessage(`創建節點 "${functionName}"，但未找到對應函數內容`, 'warning');
        }

        connections.push({
          fromNode: nodeData.id,
          fromOutput: outputIndex,
          toNode: newNode.id
        });

        drawConnections();
        e.stopPropagation();
      });
    }

    function setupOutputPort(itemElement, nodeData, outputIndex, container) {
      itemElement.querySelector('.output-port').addEventListener('mousedown', (e) => {
        if (spacePressed || e.button === 1) return;

        const rect = e.target.getBoundingClientRect();
        connecting = {
          startX: rect.left + rect.width / 2,
          startY: rect.top + rect.height / 2,
          fromNode: nodeData.id,
          fromOutput: outputIndex
        };
        container.classList.add('connecting');
        e.stopPropagation();
      });
    }

    function createFunctionItems(nodeData, functionNames, container) {
      const itemsContainer = nodeData.element.querySelector('.items');
      itemsContainer.innerHTML = '';

      // 從內容中提取更多類型的函數名稱
      const content = getNodeContent(nodeData);
      const additionalFunctionNames = extractAdditionalFunctionNames(content);

      // 合併所有函數名稱並去重
      const allFunctionNames = [...new Set([...functionNames, ...additionalFunctionNames])];

      console.log('合併後的函數名稱:', allFunctionNames);

      allFunctionNames.forEach((name, index) => {
        const newItem = document.createElement('div');
        newItem.className = 'item';
        newItem.innerHTML = `
      <span class="drag-handle">☰</span>
      <input type="text" class="item-text" value="${name}">
      <button class="add-node-btn">+</button>
      <div class="output-port" data-type="output"></div>
    `;
        itemsContainer.appendChild(newItem);

        nodeData.outputs = allFunctionNames.map((_, i) => i);
        setupAddNodeButton(newItem, nodeData, index, container);
        setupOutputPort(newItem, nodeData, index, container);

        // 確保設置拖動功能
        setupItemDragAndDrop(nodeData.element, nodeData);
      });
    }

    function extractAdditionalFunctionNames(content) {
      const additionalNames = new Set();

      if (!content) return [];

      // 1. 提取 document.getElementById('xxx').addEventListener('click', functionName) 格式
      const eventListenerRegex = /document\.getElementById\(['"]([^'"]+)['"]\)\.addEventListener\([^,]+,\s*([^)\s,]+)/g;
      let match;

      while ((match = eventListenerRegex.exec(content)) !== null) {
        const elementId = match[1];
        const functionName = match[2];

        // 新增：過濾只含有 "(e" 的項目
        if (functionName.trim() === '(e') {
          console.log(`❌ 過濾只含有 "(e" 的事件監聽器函數: "${functionName}"`);
          continue;
        }

        console.log(`找到事件監聽器格式: 元素ID="${elementId}", 函數名="${functionName}"`);

        // 檢查是否在黑名單中
        const isBlacklisted = currentLanguage === 'python'
          ? PYTHON_FUNCTION_BLACKLIST.includes(functionName)
          : FUNCTION_BLACKLIST.includes(functionName);

        if (!isBlacklisted) {
          additionalNames.add(functionName);
          console.log(`✅ 包含函數: "${functionName}"`);
        } else {
          console.log(`❌ 排除黑名單函數: "${functionName}"`);
        }
      }

      // 2. 提取 onclick="functionName()" 格式
      const onclickRegex = /onclick\s*=\s*["']([^("']+)\([^)]*\)["']/g;
      while ((match = onclickRegex.exec(content)) !== null) {
        const functionName = match[1];

        // 新增：過濾只含有 "(e" 的項目
        if (functionName.trim() === '(e') {
          console.log(`❌ 過濾只含有 "(e" 的onclick函數: "${functionName}"`);
          continue;
        }

        console.log(`找到onclick格式: 函數名="${functionName}"`);

        const isBlacklisted = currentLanguage === 'python'
          ? PYTHON_FUNCTION_BLACKLIST.includes(functionName)
          : FUNCTION_BLACKLIST.includes(functionName);

        if (!isBlacklisted) {
          additionalNames.add(functionName);
          console.log(`✅ 包含函數: "${functionName}"`);
        } else {
          console.log(`❌ 排除黑名單函數: "${functionName}"`);
        }
      }

      // 3. 提取 .addEventListener('click', functionName) 格式（不帶getElementById）
      const simpleEventListenerRegex = /\.addEventListener\(['"]click['"],\s*([^)\s,]+)/g;
      while ((match = simpleEventListenerRegex.exec(content)) !== null) {
        const functionName = match[1];

        // 新增：過濾只含有 "(e" 的項目
        if (functionName.trim() === '(e') {
          console.log(`❌ 過濾只含有 "(e" 的簡單事件監聽器函數: "${functionName}"`);
          continue;
        }

        console.log(`找到簡單事件監聽器格式: 函數名="${functionName}"`);

        const isBlacklisted = currentLanguage === 'python'
          ? PYTHON_FUNCTION_BLACKLIST.includes(functionName)
          : FUNCTION_BLACKLIST.includes(functionName);

        if (!isBlacklisted) {
          additionalNames.add(functionName);
          console.log(`✅ 包含函數: "${functionName}"`);
        } else {
          console.log(`❌ 排除黑名單函數: "${functionName}"`);
        }
      }

      // 4. 提取 jQuery 格式：$('#xxx').click(functionName)
      const jqueryClickRegex = /\$\(['"]#[^'"]+['"]\)\.click\(\s*([^)\s,]+)/g;
      while ((match = jqueryClickRegex.exec(content)) !== null) {
        const functionName = match[1];

        // 新增：過濾只含有 "(e" 的項目
        if (functionName.trim() === '(e') {
          console.log(`❌ 過濾只含有 "(e" 的jQuery點擊函數: "${functionName}"`);
          continue;
        }

        console.log(`找到jQuery點擊格式: 函數名="${functionName}"`);

        const isBlacklisted = currentLanguage === 'python'
          ? PYTHON_FUNCTION_BLACKLIST.includes(functionName)
          : FUNCTION_BLACKLIST.includes(functionName);

        if (!isBlacklisted) {
          additionalNames.add(functionName);
          console.log(`✅ 包含函數: "${functionName}"`);
        } else {
          console.log(`❌ 排除黑名單函數: "${functionName}"`);
        }
      }

      // 5. 提取 jQuery 格式：$('#xxx').on('click', functionName)
      const jqueryOnRegex = /\$\(['"]#[^'"]+['"]\)\.on\(['"]click['"],\s*([^)\s,]+)/g;
      while ((match = jqueryOnRegex.exec(content)) !== null) {
        const functionName = match[1];

        // 新增：過濾只含有 "(e" 的項目
        if (functionName.trim() === '(e') {
          console.log(`❌ 過濾只含有 "(e" 的jQuery on函數: "${functionName}"`);
          continue;
        }

        console.log(`找到jQuery on格式: 函數名="${functionName}"`);

        const isBlacklisted = currentLanguage === 'python'
          ? PYTHON_FUNCTION_BLACKLIST.includes(functionName)
          : FUNCTION_BLACKLIST.includes(functionName);

        if (!isBlacklisted) {
          additionalNames.add(functionName);
          console.log(`✅ 包含函數: "${functionName}"`);
        } else {
          console.log(`❌ 排除黑名單函數: "${functionName}"`);
        }
      }

      console.log('額外提取的函數名稱:', Array.from(additionalNames));
      return Array.from(additionalNames);
    }

    // 新增清理函數，用於清理現有項目中可能存在的 "(e"
    function cleanupExistingItems(nodeData) {
      const itemsContainer = nodeData.element.querySelector('.items');
      if (!itemsContainer) return;

      const items = itemsContainer.querySelectorAll('.item');
      let removedCount = 0;

      items.forEach(item => {
        const itemText = item.querySelector('.item-text');
        if (itemText && itemText.value.trim() === '(e') {
          item.remove();
          removedCount++;
          console.log(`✅ 清理了只含有 "(e" 的項目: "${itemText.value}"`);
        }
      });

      if (removedCount > 0) {
        console.log(`✅ 總共清理了 ${removedCount} 個只含有 "(e" 的項目`);

        // 重新設置輸出索引
        const remainingItems = itemsContainer.querySelectorAll('.item');
        nodeData.outputs = Array.from(remainingItems).map((_, index) => index);

        // 重新設置事件
        remainingItems.forEach((item, index) => {
          const port = item.querySelector('.output-port');
          if (port) {
            port.dataset.outputIndex = index;
            port.dataset.originalIndex = index;
          }
          setupAddNodeButton(item, nodeData, index, container);
          setupOutputPort(item, nodeData, index, container);
        });

        setupItemDragAndDrop(nodeData.element, nodeData);
        drawConnections();
      }
    }



    function setupParagraphPopup(paragraphInput, content, nodeData) {
      const btn = document.createElement('button');
      btn.className = 'paragraph-btn';
      btn.textContent = content.length > 50 ? content.substring(0, 47) + '...' : content;

      const popup = document.createElement('div');
      popup.className = 'paragraph-popup';
      popup.textContent = content;

      // 添加節點顏色類到彈出框
      const colorClass = getCurrentColorClass(nodeData);
      popup.classList.add(colorClass);

      const container = document.createElement('div');
      container.style.position = 'relative';
      container.style.display = 'inline-block';
      container.style.width = '100%';

      // 保存原始輸入框的引用
      const originalInput = paragraphInput.cloneNode(true);
      originalInput.style.display = 'none';
      container.appendChild(originalInput);

      container.appendChild(btn);
      container.appendChild(popup);

      paragraphInput.replaceWith(container);

      // 每次點擊都創建新的彈出框容器
      btn.addEventListener('click', (e) => {
        // 移除現有的彈出框（如果存在）
        // 移除現有的彈出框（如果存在）
        if (nodeData.popupContainer) {
          nodeData.popupContainer.remove();
          nodeData.popupContainer = null;
        }

        const btnRect = btn.getBoundingClientRect();
        const btnCenterX = btnRect.left + btnRect.width / 2;
        const btnCenterY = btnRect.top + btnRect.height / 2;

        const worldX = (btnCenterX - translateX) / scale;
        const worldY = (btnCenterY - translateY) / scale;

        const popupWidth = 600;
        const popupHeight = 200;

        // 創建新的彈出框容器
        nodeData.popupContainer = document.createElement('div');
        const popupContainer = nodeData.popupContainer;

        popupContainer.style.position = 'fixed';
        popupContainer.style.left = '0';
        popupContainer.style.top = '0';
        popupContainer.style.width = `${popupWidth}px`;
        popupContainer.style.height = `${popupHeight}px`;
        popupContainer.style.transform = `
      translate(${worldX * scale + translateX - popupWidth / 2}px, 
                ${worldY * scale + translateY - popupHeight / 2}px)
    `;
        popupContainer.style.zIndex = '10000';

        // 克隆彈出框內容以避免DOM重複問題
        const popupClone = popup.cloneNode(true);
        popupClone.style.display = 'block';
        popupClone.style.position = 'absolute';
        popupClone.style.width = '100%';
        popupClone.style.height = '100%';
        popupClone.style.overflow = 'auto';

        popupContainer.appendChild(popupClone);
        document.body.appendChild(popupContainer);

        // 設置為當前活動彈出框
        activePopup = popupClone;
        popupScrollPosition = 0;
        updatePopupScroll();

        e.stopPropagation();
        analyzeVariables(nodeData);
      });

      // 保留原有的鍵盤事件監聽
      const clearContentHandler = function (e) {
        if (e.key.toLowerCase() === 'x' && activePopup === popup) {
          originalInput.value = '';
          resetItemsList(nodeData);
          container.replaceWith(originalInput);
          document.removeEventListener('keydown', clearContentHandler);
          if (nodeData.popupContainer) {
            nodeData.popupContainer.remove();
            nodeData.popupContainer = null;
          }
          activePopup = null;
          e.preventDefault();
        }
      };
      document.addEventListener('keydown', clearContentHandler);

      // 點擊外部關閉
      document.addEventListener('click', (e) => {
        if (nodeData.popupContainer &&
          !nodeData.popupContainer.contains(e.target) &&
          !container.contains(e.target)) {
          nodeData.popupContainer.remove();
          nodeData.popupContainer = null;
          activePopup = null;
        }
      });
    }

    // 新增變數分析函數
    function analyzeVariables(nodeData) {
      // 獲取內容來源，優先使用 paragraph-btn 的原始內容
      let content = '';
      const paragraphBtn = nodeData.element.querySelector('.paragraph-btn');
      const paragraphInput = nodeData.element.querySelector('.paragraph-input');

      if (paragraphBtn && paragraphBtn.dataset.originalContent) {
        content = paragraphBtn.dataset.originalContent;
      } else if (paragraphInput) {
        content = paragraphInput.value;
      }

      const variableAnalysisContent = nodeData.element.querySelector('.variable-analysis-content');

      // 清空現有內容
      variableAnalysisContent.innerHTML = '';

      // 提取變數（根據當前語言）
      const variables = extractVariables(content);

      // 如果沒有找到變數，顯示提示
      if (variables.length === 0) {
        variableAnalysisContent.innerHTML = '<div class="no-variables-message">未找到變數聲明</div>';
        return;
      }

      // 獲取當前語言
      const languageSelector = document.getElementById('code-language-selector');
      const currentLanguage = languageSelector ? languageSelector.value : 'html'; // 默認html

      // 為每個變數創建一個按鈕（過濾黑名單）
      variables.forEach(variable => {
        // 檢查是否在黑名單中
        let isBlacklisted = false;

        if (currentLanguage === 'python') {
          isBlacklisted = PYTHON_FUNCTION_BLACKLIST.includes(variable);
        } else {
          isBlacklisted = FUNCTION_BLACKLIST.includes(variable);
        }

        // 跳過黑名單中的變數
        if (isBlacklisted) {
          return; // 使用continue在forEach中無效，直接return跳過本次迭代
        }

        // 創建變數按鈕
        const variableBtn = document.createElement('button');
        variableBtn.className = 'variable-btn';
        variableBtn.textContent = variable;
        variableBtn.dataset.variableName = variable;
        variableBtn.dataset.active = 'false';

        variableBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleVariableHighlight(variable, nodeData, variableBtn);

          // 在彈出框中高亮變數名稱
          highlightVariableInPopup(variable, nodeData);
        });

        variableAnalysisContent.appendChild(variableBtn);
      });

      // 如果過濾後沒有有效變數，顯示提示
      if (variableAnalysisContent.children.length === 0) {
        variableAnalysisContent.innerHTML = '<div class="no-variables-message">所有變數都在黑名單中</div>';
        return;
      }

      // 確保內容是可見的
      const analysisContainer = nodeData.element.querySelector('.variable-analysis-container');
      if (analysisContainer) {
        analysisContainer.classList.add('expanded');
        variableAnalysisContent.style.display = 'block';
      }
    }
    function highlightVariableInPopup(variableName, nodeData) {
      // 獲取彈出框元素
      const popup = nodeData.element.querySelector('.paragraph-popup');
      if (!popup) return;

      // 清除之前的高亮
      const existingHighlights = popup.querySelectorAll('.variable-highlight');
      existingHighlights.forEach(el => {
        const parent = el.parentNode;
        parent.replaceChild(document.createTextNode(el.textContent), el);
        parent.normalize(); // 合併相鄰的文本節點
      });

      // 創建正則表達式來匹配變數名稱（確保是完整的單詞）
      // 創建正則表達式來匹配變數名稱（確保是完整的單詞）
      const regex = new RegExp(
        currentLanguage === 'python'
          ? `\\b${escapeRegExp(variableName)}\\b(?![(\[])`  // Python: 排除後面跟著(或[的情況
          : `\\b${escapeRegExp(variableName)}\\b`,         // JavaScript
        'g'
      );


      // 遍歷彈出框的所有文本節點
      const walker = document.createTreeWalker(popup, NodeFilter.SHOW_TEXT);
      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.nodeValue.trim() && regex.test(node.nodeValue)) {
          textNodes.push(node);
        }
      }

      // 高亮匹配的文本
      textNodes.forEach(textNode => {
        const parent = textNode.parentNode;
        if (parent.nodeName === 'SPAN' && parent.classList.contains('variable-highlight')) {
          return; // 已經是高亮狀態，跳過
        }

        const content = textNode.nodeValue;
        const newContent = content.replace(regex, match => {
          return `<span class="variable-highlight">${match}</span>`;
        });

        const temp = document.createElement('div');
        temp.innerHTML = newContent;

        // 替換原始文本節點
        const fragment = document.createDocumentFragment();
        while (temp.firstChild) {
          fragment.appendChild(temp.firstChild);
        }

        parent.replaceChild(fragment, textNode);
      });
    }



    // 輔助函數：轉義正則表達式中的特殊字符
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }



    // 新增變數高亮切換函數
    function toggleVariableHighlight(variable, nodeData, button) {
      const isActive = button.dataset.active === 'true';

      if (isActive) {
        // 重置所有高亮
        button.dataset.active = 'false';
        button.style.backgroundColor = '';
        resetConnectionColors();
        removeVariableHighlights(nodeData.element);

        // 清除所有相關節點的高亮
        connections.forEach(conn => {
          if (conn.highlighted) {
            const node = nodes[conn.toNode];
            removeVariableHighlights(node.element);
          }
        });
      } else {
        // 啟用高亮
        button.dataset.active = 'true';
        button.style.backgroundColor = '#4a90e2';
        highlightVariableConnections(variable, nodeData);
        highlightVariableInPopup(variable, nodeData);
      }
    }




    function removeVariableHighlights(element) {
      const popup = element.querySelector('.paragraph-popup');
      if (!popup) return;

      const highlights = popup.querySelectorAll('.variable-highlight');
      highlights.forEach(el => {
        const parent = el.parentNode;
        parent.replaceChild(document.createTextNode(el.textContent), el);
        parent.normalize();
      });
    }


    // 新增高亮變數相關連接的函數
    function highlightVariableConnections(variableName, startNode) {
      resetConnectionColors();
      const content = getNodeContent(startNode);
      if (!content.includes(variableName)) return;

      // 記錄需要高亮popup的節點
      const nodesToHighlight = new Set();

      connections.forEach(conn => {
        if (conn.fromNode === startNode.id) {
          const childNode = nodes[conn.toNode];
          const childContent = getNodeContent(childNode);

          if (childContent.includes(variableName)) {
            // 標記需要高亮的連接線
            conn.highlighted = true;
            // 記錄需要高亮popup的節點
            nodesToHighlight.add(childNode);
          }
        }
      });

      // 高亮所有相關節點的popup
      nodesToHighlight.forEach(node => {
        highlightVariableInPopup(variableName, node);
      });

      drawConnections();
    }

    // 輔助函數：獲取節點內容
    function getNodeContent(node) {
      const btn = node.element.querySelector('.paragraph-btn');
      const input = node.element.querySelector('.paragraph-input');
      return (btn?.dataset.originalContent || input?.value) || '';
    }



    // 新增提取變數的輔助函數
    function extractVariables(content) {
      const variables = new Set();

      if (currentLanguage === 'python') {
        // Python 變數提取
        const assignmentRegex = /^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*=/gm;
        const forLoopRegex = /for\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+in/g;
        const functionParamRegex = /def\s+\w+\s*\(([^)]*)\)/g;

        let match;
        while ((match = assignmentRegex.exec(content)) !== null) {
          variables.add(match[1]);
        }
        while ((match = forLoopRegex.exec(content)) !== null) {
          variables.add(match[1]);
        }
        while ((match = functionParamRegex.exec(content)) !== null) {
          match[1].split(',').forEach(param => {
            const cleanParam = param.trim().split('=')[0];
            if (cleanParam) variables.add(cleanParam);
          });
        }
      } else {
        // JavaScript 變數提取
        const variableRegex = /(?:const|let|var)\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/g;
        let match;
        while ((match = variableRegex.exec(content)) !== null) {
          variables.add(match[1]);
        }
      }

      return Array.from(variables);
    }


    // 新增重置連接顏色的函數
    function resetConnectionColors() {
      connections.forEach(conn => {
        conn.highlighted = false;
      });
      drawConnections();
    }




    function getCurrentColorClass(nodeData) {
      const nodeElement = nodeData.element;
      for (const colorClass of COLOR_CLASSES) {
        if (nodeElement.classList.contains(colorClass)) {
          return colorClass;
        }
      }
      return COLOR_CLASSES[0]; // 默認顏色
    }


    function changeNodeColor(nodeData, colorIndex) {
      // 移除所有顏色類
      nodeData.element.classList.remove(...COLOR_CLASSES);

      // 添加新顏色類
      const newColorClass = COLOR_CLASSES[colorIndex % COLOR_CLASSES.length];
      nodeData.element.classList.add(newColorClass);

      // 更新節點數據
      nodeData.colorIndex = colorIndex;

      // 更新彈出框顏色（如果存在）
      const popup = nodeData.element.querySelector('.paragraph-popup');
      if (popup) {
        popup.classList.remove(...COLOR_CLASSES);
        popup.classList.add(newColorClass);
      }

      // 更新彈出框容器顏色（如果存在）
      if (nodeData.popupContainer) {
        const popupInContainer = nodeData.popupContainer.querySelector('.paragraph-popup');
        if (popupInContainer) {
          popupInContainer.classList.remove(...COLOR_CLASSES);
          popupInContainer.classList.add(newColorClass);
        }
      }
    }



    function resetItemsList(nodeData) {
      const itemsContainer = nodeData.element.querySelector('.items');
      itemsContainer.innerHTML = `
    <div class="item">
      <span class="drag-handle">☰</span>
      <input type="text" class="item-text" value="">
      <button class="add-node-btn">+</button>
      <div class="output-port" data-type="output"></div>
    </div>
  `;

      nodeData.outputs = [0];
      const newItem = itemsContainer.querySelector('.item');
      setupAddNodeButton(newItem, nodeData, 0, container);
      setupOutputPort(newItem, nodeData, 0, container);
      setupItemDragAndDrop(nodeData.element, nodeData); // 新增這行

      // 恢復輸入框（如果被替換）
      const containerDiv = nodeData.element.querySelector('.paragraph-container');
      if (containerDiv) {
        const textarea = document.createElement('textarea');
        textarea.className = 'paragraph-input';
        textarea.placeholder = '貼上段落內容...';
        containerDiv.replaceWith(textarea);
      }
    }


    function toggleNodeColors() {
      selectedNodes.forEach(nodeId => {
        const node = nodes[nodeId];
        if (node) {
          const nodeElement = node.element;
          const popup = nodeElement.querySelector('.paragraph-popup');

          // 使用節點自己的 colorIndex 或默認使用 currentColorIndex
          const nodeColorIndex = node.colorIndex !== undefined ? node.colorIndex : currentColorIndex;

          // 計算下一個顏色索引
          const nextColorIndex = (nodeColorIndex + 1) % COLOR_CLASSES.length;

          // 移除所有顏色類
          COLOR_CLASSES.forEach(cls => {
            nodeElement.classList.remove(cls);
            if (popup) popup.classList.remove(cls);
          });

          // 添加新顏色類
          const isTransparent = nodeElement.classList.contains('transparent');
          const colorClass = isTransparent ?
            `transparent ${COLOR_CLASSES[nextColorIndex]}` :
            COLOR_CLASSES[nextColorIndex];

          nodeElement.className = nodeElement.className.split(' ')
            .filter(c => !COLOR_CLASSES.includes(c) && c !== 'transparent')
            .join(' ') + ' ' + colorClass;

          // 更新彈出框顏色
          if (popup) {
            popup.className = popup.className.split(' ')
              .filter(c => !COLOR_CLASSES.includes(c))
              .join(' ') + ' ' + COLOR_CLASSES[nextColorIndex];
          }

          // 更新節點的顏色索引
          node.colorIndex = nextColorIndex;
        }
      });

      // 更新全局 currentColorIndex 以便新選中的節點使用
      currentColorIndex = (currentColorIndex + 1) % COLOR_CLASSES.length;

      showStatusMessage(`已切換到下一個顏色`, 'success');
    }

    // Create GROUP-NODE element
    // 創建群組節點元素
    function createGroupNodeElement(x, y, title = '群組節點') {
      const node = document.createElement('div');
      node.className = 'node group-node';
      node.style.left = `${x}px`;
      node.style.top = `${y}px`;
      node.innerHTML = `
    <div class="node-header">
      <div class="input-port" data-type="input"></div>
      <button class="collapse-btn">-</button>
      <button class="jump-to-btn hidden" title="跳轉到同名節點"></button>
      <input type="text" class="node-title" value="${title}">
      <button class="delete-node-btn">×</button>
      <button class="ungroup-btn">解散</button>
      <div class="output-port header-port" data-type="output" style="display:none"></div>
    </div>
    <div class="collapsible">
      <div class="group-node-info">包含 0 個節點</div>
      <div class="items">
        <div class="item">
          <input type="text" class="item-text" value="">
          <button class="add-node-btn">+</button>
          <div class="output-port" data-type="output" data-output-index="0"></div>
        </div>
      </div>
    </div>
  `;

      nodesContainer.appendChild(node);
      return node;
    }

    // 修改後的 initializeGroupNodeData 函數，確保正確初始化連接數據
    function initializeGroupNodeData(node, x, y, containedNodes = []) {
      const nodeData = {
        element: node,
        id: nodes.length,
        outputs: [0],
        x,
        y,
        jumpIndex: 0,
        isGroupNode: true,
        containedNodes: containedNodes,
        originalConnections: [],  // 保存原始連接
        incomingConnections: [],  // 進入群組的連接
        outgoingConnections: []   // 離開群組的連接
      };

      // 保存所有被包含節點的原始連接
      containedNodes.forEach(nodeId => {
        const originalNode = nodes[nodeId];
        if (originalNode) {
          const nodeConnections = {
            nodeId: originalNode.id,
            incoming: [],
            outgoing: []
          };

          // 收集進入該節點的連接
          connections.forEach(conn => {
            if (conn.toNode === originalNode.id) {
              nodeConnections.incoming.push({
                fromNode: conn.fromNode,
                fromOutput: conn.fromOutput,
                toNode: conn.toNode
              });
            }
          });

          // 收集從該節點出去的連接
          connections.forEach(conn => {
            if (conn.fromNode === originalNode.id) {
              nodeConnections.outgoing.push({
                fromNode: conn.fromNode,
                fromOutput: conn.fromOutput,
                toNode: conn.toNode
              });
            }
          });

          nodeData.originalConnections.push(nodeConnections);
        }
      });

      nodes.push(nodeData);
      updateGroupNodeInfo(nodeData);

      // 設置跳轉按鈕
      const jumpBtn = node.querySelector('.jump-to-btn');
      jumpBtn.addEventListener('click', (e) => {
        jumpToSameNameNode(nodeData);
        e.stopPropagation();
      });

      return nodeData;
    }

    // Update group node info display
    function updateGroupNodeInfo(groupNode) {
      const infoElement = groupNode.element.querySelector('.group-node-info');
      if (infoElement) {
        infoElement.textContent = `包含 ${groupNode.containedNodes.length} 個節點`;
      }
    }

    // Setup ungroup button
    function setupUngroupButton(node, nodeData) {
      const ungroupBtn = node.querySelector('.ungroup-btn');
      if (!ungroupBtn) return;

      // 移除現有事件監聽器
      ungroupBtn.replaceWith(ungroupBtn.cloneNode(true));
      const newUngroupBtn = node.querySelector('.ungroup-btn');

      newUngroupBtn.addEventListener('click', (e) => {
        ungroupNodes(nodeData);
        e.stopPropagation();
      });
    }

    // Ungroup nodes
    function ungroupNodes(groupNode) {
      if (!groupNode || !groupNode.isGroupNode) return;

      try {
        // 1. 恢復被包含節點的可見性
        groupNode.containedNodes.forEach(nodeId => {
          const node = nodes[nodeId];
          if (node) {
            node.element.style.display = ''; // 恢復顯示
          }
        });

        // 2. 恢復原始連接
        // 先移除所有與群組節點相關的連接
        connections = connections.filter(conn =>
          conn.fromNode !== groupNode.id && conn.toNode !== groupNode.id
        );

        // 恢復原始連接
        groupNode.originalConnections.forEach(connData => {
          // 恢復進入該節點的連接
          connData.incoming.forEach(conn => {
            connections.push({
              fromNode: conn.fromNode,
              fromOutput: conn.fromOutput,
              toNode: connData.nodeId
            });
          });

          // 恢復從該節點出去的連接
          connData.outgoing.forEach(conn => {
            connections.push({
              fromNode: connData.nodeId,
              fromOutput: conn.fromOutput,
              toNode: conn.toNode
            });
          });
        });

        // 3. 從節點列表中移除群組節點
        const index = nodes.findIndex(n => n.id === groupNode.id);
        if (index !== -1) {
          nodes.splice(index, 1);
          groupNode.element.remove();
        }

        // 4. 重新索引節點ID
        nodes.forEach((n, i) => {
          n.id = i;
        });

        // 5. 更新連接中的節點ID引用
        connections.forEach(conn => {
          if (conn.fromNode > groupNode.id) conn.fromNode--;
          if (conn.toNode > groupNode.id) conn.toNode--;
        });

        drawConnections();
        updateNodeList();
        showStatusMessage('群組已成功解散', 'success');
      } catch (error) {
        console.error('解散群組失敗:', error);
        showStatusMessage('解散群組時發生錯誤', 'error');
      }
    }
    // 從選中的節點創建群組節點
    function createGroupNodeFromSelection() {
      if (selectedNodes.size < 2) return;

      const selectedNodesData = Array.from(selectedNodes)
        .map(id => nodes[id])
        .filter(node => node && !node.isGroupNode);

      if (selectedNodesData.length < 2) return;

      // 計算群組節點位置（選中節點的中心點）
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      selectedNodesData.forEach(node => {
        const rect = node.element.getBoundingClientRect();
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x + rect.width / scale);
        maxY = Math.max(maxY, node.y + rect.height / scale);
      });

      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;

      // 創建群組節點
      const groupNodeElement = createGroupNodeElement(centerX, centerY);
      const groupNodeData = initializeGroupNodeData(
        groupNodeElement,
        centerX,
        centerY,
        selectedNodesData.map(n => n.id)
      );

      // 隱藏被群組的節點
      selectedNodesData.forEach(node => {
        node.element.style.display = 'none';
      });

      // 設置群組節點的ITEM名稱
      const itemsContainer = groupNodeElement.querySelector('.items');
      itemsContainer.innerHTML = '';

      // 收集所有輸出連接
      const outputMap = new Map();
      selectedNodesData.forEach(node => {
        connections.forEach(conn => {
          if (conn.fromNode === node.id) {
            if (!outputMap.has(conn.fromOutput)) {
              outputMap.set(conn.fromOutput, []);
            }
            outputMap.get(conn.fromOutput).push({
              toNode: conn.toNode,
              nodeTitle: nodes[conn.toNode].element.querySelector('.node-title').value
            });
          }
        });
      });

      // 創建ITEM
      outputMap.forEach((connections, outputIndex) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'item';

        // 使用第一個連接的子節點名稱作為ITEM名稱
        const itemName = connections[0].nodeTitle || `輸出 ${outputIndex + 1}`;

        itemDiv.innerHTML = `
      <input type="text" class="item-text" value="${escapeHtml(itemName)}">
      <button class="add-node-btn">+</button>
      <div class="output-port" data-type="output" data-output-index="${outputIndex}"></div>
    `;

        itemsContainer.appendChild(itemDiv);

        // 設置事件
        setupAddNodeButton(itemDiv, groupNodeData, outputIndex, container);
        setupOutputPort(itemDiv, groupNodeData, outputIndex, container);
      });

      // 處理連接
      processGroupNodeConnections(groupNodeData, selectedNodesData);

      // 設置群組節點事件
      setupGroupNodeEvents(groupNodeElement, groupNodeData);

      // 清除選中狀態
      clearSelection();

      return groupNodeData;
    }

    // 處理群組節點的連接
    // 修改後的 processGroupNodeConnections 函數，確保正確處理連接關係
    function processGroupNodeConnections(groupNode, containedNodes) {
      const containedNodeIds = new Set(containedNodes.map(n => n.id));

      // 找出所有進入群組的連接（外部節點 -> 群組內節點）
      groupNode.incomingConnections = connections.filter(conn =>
        !containedNodeIds.has(conn.fromNode) &&
        containedNodeIds.has(conn.toNode)
      ).map(conn => ({
        fromNode: conn.fromNode,
        fromOutput: conn.fromOutput,
        toNode: conn.toNode
      }));

      // 找出所有離開群組的連接（群組內節點 -> 外部節點）
      groupNode.outgoingConnections = connections.filter(conn =>
        containedNodeIds.has(conn.fromNode) &&
        !containedNodeIds.has(conn.toNode)
      ).map(conn => ({
        fromNode: conn.fromNode,
        fromOutput: conn.fromOutput,
        toNode: conn.toNode
      }));

      // 移除所有與被包含節點相關的原始連接
      connections = connections.filter(conn =>
        !containedNodeIds.has(conn.fromNode) &&
        !containedNodeIds.has(conn.toNode)
      );

      // 為群組節點創建輸入埠（基於進入群組的連接）
      const inputSources = new Set();
      groupNode.incomingConnections.forEach(conn => {
        inputSources.add(conn.fromNode);

        // 創建從原始來源節點到群組節點的連接
        connections.push({
          fromNode: conn.fromNode,
          fromOutput: conn.fromOutput,
          toNode: groupNode.id
        });
      });

      // 為群組節點創建輸出埠（基於離開群組的連接）
      const outputTargets = new Map();
      groupNode.outgoingConnections.forEach(conn => {
        if (!outputTargets.has(conn.fromOutput)) {
          outputTargets.set(conn.fromOutput, []);
        }
        outputTargets.get(conn.fromOutput).push(conn.toNode);

        // 創建從群組節點到原始目標節點的連接
        connections.push({
          fromNode: groupNode.id,
          fromOutput: conn.fromOutput,
          toNode: conn.toNode
        });
      });

      // 更新群組節點的輸出埠
      if (outputTargets.size > 0) {
        groupNode.outputs = Array.from(outputTargets.keys());
        updateGroupNodeItems(groupNode);
      }

      drawConnections();
    }

    // 更新群組節點的項目列表
    function updateGroupNodeItems(groupNode) {
      const itemsContainer = groupNode.element.querySelector('.items');
      itemsContainer.innerHTML = '';

      groupNode.outputs.forEach((outputIndex, i) => {
        const newItem = document.createElement('div');
        newItem.className = 'item';
        newItem.innerHTML = `
      <input type="text" class="item-text" value="輸出 ${i + 1}">
      <button class="add-node-btn">+</button>
      <div class="output-port" data-type="output" data-output-index="${outputIndex}"></div>
    `;
        itemsContainer.appendChild(newItem);

        setupAddNodeButton(newItem, groupNode, outputIndex, container);
        setupOutputPort(newItem, groupNode, outputIndex, container);
      });
    }

    // 設置群組節點的事件
    function setupGroupNodeEvents(node, nodeData) {
      setupNodeDrag(node, nodeData);
      setupCollapseButton(node, nodeData);
      setupDeleteButton(node, nodeData);
      setupUngroupButton(node, nodeData);
      setupTitleInput(node);
      setupPortEvents(node, nodeData);
    }


    // 主函數
    function createNode(x, y, title = '節點', type = 'normal', content = null) {
      console.log(`創建節點: 標題="${title}", 內容=${content ? '有' : '無'}`);

      if (type === 'group') {
        const node = createGroupNodeElement(x, y, title);
        const nodeData = initializeGroupNodeData(node, x, y);
        setupGroupNodeEvents(node, nodeData);
        return nodeData;
      } else {
        const node = createNodeElement(x, y, title);
        const nodeData = initializeNodeData(node, x, y);

        // 如果有內容，立即填充
        if (content) {
          const paragraphInput = node.querySelector('.paragraph-input');
          if (paragraphInput) {
            console.log(`正在填充內容到節點 "${title}"`);
            paragraphInput.value = content;

            // 立即觸發輸入事件以自動分析變數和創建項目
            const inputEvent = new Event('input', { bubbles: true });
            paragraphInput.dispatchEvent(inputEvent);

            // 確保變數分析也被觸發
            setTimeout(() => {
              analyzeVariables(nodeData);
            }, 50);
          }
        }

        setupNodeDrag(node, nodeData);
        setupCollapseButton(node, nodeData);
        setupDeleteButton(node, nodeData);
        setupTitleInput(node);
        setupParagraphInput(node, nodeData);
        setupInitialAddButton(node, nodeData);
        setupAddItemButton(node, nodeData);
        setupHideChildrenButton(node, nodeData);
        setupGenerateButton(node, nodeData);
        setupPortEvents(node, nodeData);
        updateNodePosition(nodeData);
        setupVariableAnalysis(node, nodeData);

        return nodeData;
      }
    }






    function setupCollapseButton(node, nodeData) {
      const collapseBtn = node.querySelector('.collapse-btn');
      collapseBtn.addEventListener('click', (e) => {
        node.classList.toggle('collapsed');

        const collapsible = node.querySelector('.collapsible');
        const originalPorts = node.querySelectorAll('.output-port:not(.header-port)');
        const headerPort = node.querySelector('.header-port');

        if (node.classList.contains('collapsed')) {
          originalPorts.forEach(port => port.style.display = 'none');
          if (!headerPort) {
            const port = document.createElement('div');
            port.className = 'output-port header-port';
            port.dataset.type = 'output';
            port.style.display = 'block';
            node.querySelector('.node-header').appendChild(port);
          } else {
            headerPort.style.display = 'block';
          }
          collapseBtn.textContent = '+';
        } else {
          originalPorts.forEach(port => port.style.display = 'block');
          if (headerPort) headerPort.style.display = 'none';
          collapseBtn.textContent = '-';
        }

        drawConnections();
        e.stopPropagation();
      });
    }

    // 創建節點DOM元素
    function createNodeElement(x, y, title) {
      const node = document.createElement('div');
      node.className = `node ${COLOR_CLASSES[0]}`;
      node.style.left = `${x}px`;
      node.style.top = `${y}px`;
      node.innerHTML = `
<div class="node-header">
  <div class="input-port" data-type="input"></div>
  <button class="collapse-btn">-</button>
  <button class="jump-to-btn hidden" title="跳轉到同名節點"></button>
  <input type="text" class="node-title" value="${title}">
  <button class="delete-node-btn">×</button>
  <div class="output-port header-port" data-type="output" style="display:none"></div>
</div>
    <div class="collapsible">
      <textarea class="paragraph-input" placeholder="貼上段落內容..."></textarea>
      <div class="items">
        <div class="item">
          <span class="drag-handle">☰</span>
          <input type="text" class="item-text" value="">
          <button class="add-node-btn">+</button>
          <div class="output-port" data-type="output" data-output-index="0"></div>
        </div>
      </div>
      <div class="buttons-container">
        <button class="add-item-btn">新加項目</button>
        <button class="hide-children-btn">隱藏子</button>
        <button class="generate-btn">一次生成</button>
      </div>
      <!-- 變數分析容器 -->
      <div class="variable-analysis-container">
  <div class="variable-analysis-container">
    <div class="variable-analysis-header">
      <span class="variable-analysis-title">變數分析</span>
      <button class="toggle-variable-analysis-btn">−</button>
    </div>
    <div class="variable-analysis-content" style="display:block"></div>
  </div>
</div>
  `;

      nodesContainer.appendChild(node);
      return node;
    }


    // 添加專用的變數分析框事件處理
    function setupVariableAnalysis(node, nodeData) {
      const header = node.querySelector('.variable-analysis-header');
      const toggleBtn = node.querySelector('.toggle-variable-analysis-btn');
      const content = node.querySelector('.variable-analysis-content');

      // 點擊整個標題區域都可以切換
      header.addEventListener('click', (e) => {
        // 確保不是點擊在切換按鈕上
        if (!e.target.classList.contains('toggle-variable-analysis-btn')) {
          toggleAnalysis(content, toggleBtn);
        }
      });

      // 點擊切換按鈕
      toggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleAnalysis(content, toggleBtn);
      });

      // 初始狀態
      content.style.display = 'block';
      toggleBtn.textContent = '−';
    }

    function toggleAnalysis(content, toggleBtn) {
      if (content.style.display === 'none') {
        content.style.display = 'block';
        toggleBtn.textContent = '−';
      } else {
        content.style.display = 'none';
        toggleBtn.textContent = '+';
      }
    }



    // 新增拖動排序功能
    function setupItemDragAndDrop(node, nodeData) {
      const itemsContainer = node.querySelector('.items');

      itemsContainer.querySelectorAll('.drag-handle').forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          if (e.button !== 0) return;

          const item = e.target.closest('.item');
          if (!item) return;

          e.preventDefault();

          // 初始化時確保所有埠都有原始索引
          nodeData.element.querySelectorAll('.output-port').forEach(port => {
            if (!port.dataset.originalIndex) {
              port.dataset.originalIndex = port.dataset.outputIndex ||
                Array.from(itemsContainer.children).indexOf(port.closest('.item'));
            }
          });

          const items = Array.from(itemsContainer.children);
          const originalIndex = items.indexOf(item);

          const dragState = {
            startX: e.clientX,
            startY: e.clientY,
            item: item,
            originalIndex: originalIndex,
            currentIndex: originalIndex,
            placeholder: createPlaceholder(item),
            isDragging: false
          };

          function onDragMove(e) {
            if (!dragState.isDragging) {
              const dx = e.clientX - dragState.startX;
              const dy = e.clientY - dragState.startY;
              if (Math.sqrt(dx * dx + dy * dy) < 5) return;

              dragState.isDragging = true;
              item.classList.add('dragging');
              item.style.position = 'absolute';
              item.style.zIndex = '1000';
              item.style.opacity = '0.8';

              itemsContainer.insertBefore(dragState.placeholder, item);
            }

            item.style.left = (e.clientX - dragState.startX) + 'px';
            item.style.top = (e.clientY - dragState.startY) + 'px';

            const items = Array.from(itemsContainer.children).filter(el => el !== dragState.placeholder);
            const itemRect = item.getBoundingClientRect();
            const itemCenterY = itemRect.top + itemRect.height / 2;

            for (let i = 0; i < items.length; i++) {
              const otherItem = items[i];
              if (otherItem === item) continue;

              const otherRect = otherItem.getBoundingClientRect();
              const otherCenterY = otherRect.top + otherRect.height / 2;

              if (Math.abs(itemCenterY - otherCenterY) < otherRect.height / 2) {
                const newIndex = i;
                if (newIndex !== dragState.currentIndex) {
                  itemsContainer.insertBefore(
                    dragState.placeholder,
                    newIndex > dragState.currentIndex ? items[newIndex].nextSibling : items[newIndex]
                  );
                  dragState.currentIndex = newIndex;
                }
                break;
              }
            }
          }

          function onDragEnd() {
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);

            if (dragState.isDragging) {
              // 將項目放回新位置
              itemsContainer.insertBefore(item, dragState.placeholder);
              item.classList.remove('dragging');
              item.style.position = '';
              item.style.left = '';
              item.style.top = '';
              item.style.zIndex = '';
              item.style.opacity = '';

              // 只有在位置改變時才更新連接
              if (dragState.originalIndex !== dragState.currentIndex) {
                updateConnectionsAfterDrag(nodeData, dragState.originalIndex, dragState.currentIndex);

                // 強制重繪所有連接
                drawConnections();

                // 確保節點位置更新
                updateNodePosition(nodeData);

                // 更新節點列表
                updateNodeList();
              }
            }

            dragState.placeholder.remove();
          }

          document.addEventListener('mousemove', onDragMove);
          document.addEventListener('mouseup', onDragEnd);
        });
      });
    }

    function updateConnectionsAfterDrag(nodeData, oldIndex, newIndex) {
      // 1. 獲取所有項目
      const items = Array.from(nodeData.element.querySelectorAll('.item'));

      // 2. 建立完整的索引映射表
      const indexMap = {};
      items.forEach((item, newIdx) => {
        const port = item.querySelector('.output-port');
        const oldIdx = parseInt(port.dataset.originalIndex);
        indexMap[oldIdx] = newIdx;

        // 更新埠索引屬性
        port.dataset.outputIndex = newIdx;
        port.dataset.originalIndex = newIdx;
      });

      // 3. 更新節點數據
      nodeData.outputs = Array(items.length).fill(0);

      // 4. 更新所有相關連接
      connections.forEach(conn => {
        if (conn.fromNode === nodeData.id && indexMap[conn.fromOutput] !== undefined) {
          conn.fromOutput = indexMap[conn.fromOutput];
        }
      });

      // 5. 強制重繪
      drawConnections();
    }

    function createPlaceholder(item) {
      const placeholder = document.createElement('div');
      placeholder.className = 'item-placeholder';
      placeholder.style.height = item.offsetHeight + 'px';
      placeholder.style.margin = '5px 0';
      placeholder.style.background = 'rgba(0,0,0,0.1)';
      placeholder.style.borderRadius = '4px';
      return placeholder;
    }

    // 創建拖動佔位符
    function createPlaceholder(item) {
      const placeholder = document.createElement('div');
      placeholder.className = 'item-placeholder';
      placeholder.style.height = item.offsetHeight + 'px';
      placeholder.style.margin = '5px 0';
      placeholder.style.background = 'rgba(0,0,0,0.1)';
      placeholder.style.borderRadius = '4px';
      return placeholder;
    }

    // 添加折疊按鈕事件處理
    function setupCollapseButton(node, nodeData) {
      const collapseBtn = node.querySelector('.collapse-btn');
      collapseBtn.addEventListener('click', (e) => {
        node.classList.toggle('collapsed');

        const collapsible = node.querySelector('.collapsible');
        const originalPorts = node.querySelectorAll('.output-port:not(.header-port)');
        const headerPort = node.querySelector('.header-port');

        if (node.classList.contains('collapsed')) {
          originalPorts.forEach(port => port.style.display = 'none');
          if (!headerPort) {
            const port = document.createElement('div');
            port.className = 'output-port header-port';
            port.dataset.type = 'output';
            port.style.display = 'block';
            node.querySelector('.node-header').appendChild(port);
          } else {
            headerPort.style.display = 'block';
          }
          collapseBtn.textContent = '+';
        } else {
          originalPorts.forEach(port => port.style.display = 'block');
          if (headerPort) headerPort.style.display = 'none';
          collapseBtn.textContent = '-';
        }

        drawConnections();
        e.stopPropagation();
      });
    }

    function setupHideChildrenButton(node, nodeData) {
      const hideChildrenBtn = node.querySelector('.hide-children-btn');

      nodeData.childStates = new Map();

      hideChildrenBtn.addEventListener('click', (e) => {
        const childNodes = connections
          .filter(conn => conn.fromNode === nodeData.id)
          .map(conn => nodes[conn.toNode]);

        if (!node.classList.contains('children-hidden')) {
          node.classList.add('children-hidden');
          hideChildrenBtn.textContent = '顯示子';

          childNodes.forEach((child, index) => {
            nodeData.childStates.set(child.id, {
              x: child.x,
              y: child.y,
              collapsed: child.element.classList.contains('collapsed')
            });

            if (!child.element.classList.contains('collapsed')) {
              child.element.querySelector('.collapse-btn').click();
            }

            // 標準位置計算
            let chilBetweenPos = 38;
            let childY = nodeData.y + (index * chilBetweenPos / scale);
            let FirsChilPos = 100;


            // 如果是第一個子節點（index === 0），調整它的 Y 位置
            if (index === 0) {
              childY += FirsChilPos / scale;  // 明確加上 50px（並考慮縮放比例）
            } else {
              childY = nodeData.y + FirsChilPos / scale + (index * chilBetweenPos / scale);
            }


            child.x = nodeData.x + 210 / scale;
            child.y = childY; // 使用調整後的 Y 值
            updateNodePosition(child);
          });
        } else {
          node.classList.remove('children-hidden');
          hideChildrenBtn.textContent = '隱藏子';

          const sortedChildren = childNodes
            .map(child => ({
              node: child,
              originalState: nodeData.childStates.get(child.id)
            }))
            .filter(child => child.originalState)
            .sort((a, b) => a.originalState.y - b.originalState.y);

          let hasOverlap = false;
          for (let i = 1; i < sortedChildren.length; i++) {
            const prevChild = sortedChildren[i - 1];
            const currChild = sortedChildren[i];
            const prevHeight = prevChild.node.element.getBoundingClientRect().height / scale;
            const prevBottom = prevChild.originalState.y + prevHeight;
            if (currChild.originalState.y < prevBottom) {
              hasOverlap = true;
              break;
            }
          }

          if (hasOverlap) {
            let currentY = sortedChildren[0]?.originalState.y || nodeData.y;
            sortedChildren.forEach(({ node, originalState }) => {
              node.x = originalState.x;
              node.y = currentY;
              updateNodePosition(node);

              const isCurrentlyCollapsed = node.element.classList.contains('collapsed');
              if (isCurrentlyCollapsed !== originalState.collapsed) {
                node.element.querySelector('.collapse-btn').click();
              }

              const nodeHeight = node.element.getBoundingClientRect().height / scale;
              currentY += nodeHeight + 10 / scale;
            });
          } else {
            sortedChildren.forEach(({ node, originalState }) => {
              node.x = originalState.x;
              node.y = originalState.y;
              updateNodePosition(node);

              const isCurrentlyCollapsed = node.element.classList.contains('collapsed');
              if (isCurrentlyCollapsed !== originalState.collapsed) {
                node.element.querySelector('.collapse-btn').click();
              }
            });
          }

          nodeData.childStates.clear();
        }

        drawConnections();
        e.stopPropagation();
      });
    }


    // 修改 updateJumpButton 函數
    function updateJumpButton(node) {
      const title = node.element.querySelector('.node-title').value;
      const jumpBtn = node.element.querySelector('.jump-to-btn');

      // 查找所有同名節點
      const sameNameNodes = nodes.filter(n =>
        n.id !== node.id &&
        n.element.querySelector('.node-title').value === title
      );

      if (sameNameNodes.length > 0) {
        jumpBtn.classList.remove('hidden');
        jumpBtn.setAttribute('data-count', sameNameNodes.length);
        jumpBtn.title = `顯示同名節點 (共 ${sameNameNodes.length} 個)`;
      } else {
        jumpBtn.classList.add('hidden');
        jumpBtn.removeAttribute('data-count');
      }
    }

    // 跳轉到同名節點
    // 修改 jumpToSameNameNode 函數
    function jumpToSameNameNode(node) {
      const title = node.element.querySelector('.node-title').value;
      const sameNameNodes = nodes.filter(n =>
        n.id !== node.id &&
        n.element.querySelector('.node-title').value === title
      );

      if (sameNameNodes.length > 0) {
        // 移除所有現有的高亮
        document.querySelectorAll('.node').forEach(n => {
          n.classList.remove('highlight');
        });

        // 高亮所有同名節點
        sameNameNodes.forEach(targetNode => {
          targetNode.element.classList.add('highlight');
        });

        // 顯示提示信息
        showJumpHint(node, node.jumpIndex + 1, sameNameNodes.length);

        // 更新跳轉索引
        node.jumpIndex = (node.jumpIndex + 1) % sameNameNodes.length;

        // 設置定時器移除高亮
        setTimeout(() => {
          sameNameNodes.forEach(targetNode => {
            targetNode.element.classList.remove('highlight');
          });
        }, 10000);
      }
    }

    // 顯示跳轉順序提示
    function showJumpHint(node, current, total) {
      const hint = document.createElement('div');
      hint.className = 'jump-hint';
      hint.textContent = `${current}/${total}`;
      hint.style.position = 'absolute';
      hint.style.left = '20px';
      hint.style.top = '20px';
      hint.style.background = 'rgba(255, 204, 0, 0.8)';
      hint.style.color = 'black';
      hint.style.padding = '5px 10px';
      hint.style.borderRadius = '10px';
      hint.style.zIndex = '10000';

      document.body.appendChild(hint);

      setTimeout(() => {
        hint.style.opacity = '0';
        hint.style.transition = 'opacity 0.5s';
        setTimeout(() => hint.remove(), 500);
      }, 1000);
    }




    // 初始化節點數據
    function initializeNodeData(node, x, y) {
      const nodeData = {
        element: node,
        id: nodes.length,
        outputs: [0],
        x,
        y,
        jumpIndex: 0,
        colorIndex: 0
      };
      nodes.push(nodeData);

      // 設置跳轉按鈕事件
      const jumpBtn = node.querySelector('.jump-to-btn');
      jumpBtn.addEventListener('click', (e) => {
        jumpToSameNameNode(nodeData);
        e.stopPropagation();
      });

      // 新增：延遲清理現有項目中可能存在的 "(e"
      setTimeout(() => {
        cleanupExistingItems(nodeData);
      }, 100);

      return nodeData;
    }

    // 設置節點拖拽
    function setupNodeDrag(node, nodeData) {
      node.addEventListener('mousedown', (e) => {
        if (e.target.className.includes('node') || e.target.className === 'node-title') {
          if (spacePressed || e.button === 1) return;

          draggingNode = nodeData;
          dragStartWorldX = toWorldX(e.clientX);
          dragStartWorldY = toWorldY(e.clientY);
          dragOffsetX = dragStartWorldX - nodeData.x;
          dragOffsetY = dragStartWorldY - nodeData.y;

          e.stopPropagation();
        }
      });
    }

    // 設置刪除按鈕
    // 修改刪除節點函數
    function setupDeleteButton(node, nodeData) {
      node.querySelector('.delete-node-btn').addEventListener('click', (e) => {
        // 移除所有與該節點相關的連接
        connections = connections.filter(conn =>
          conn.fromNode !== nodeData.id && conn.toNode !== nodeData.id
        );

        // 重新索引節點ID
        nodes = nodes.filter(n => n.id !== nodeData.id);
        nodes.forEach((n, index) => {
          n.id = index; // 重新分配連續的ID
        });

        // 更新連接中的節點ID引用
        connections.forEach(conn => {
          if (conn.fromNode > nodeData.id) conn.fromNode--;
          if (conn.toNode > nodeData.id) conn.toNode--;
        });

        node.remove();
        drawConnections();
        //updateSameNameHighlights(); // 刪除後更新高亮
        e.stopPropagation();
      });
    }

    // 設置標題輸入
    function setupTitleInput(node) {
      const titleInput = node.querySelector('.node-title');

      // 添加blur事件處理器來在點擊外部時退出編輯狀態
      titleInput.addEventListener('blur', () => {
        titleInput.value = titleInput.value.trim();
        handleTitleChange(node, titleInput);
      });

      // 2. 修改輸入處理，排除特定按鍵
      titleInput.addEventListener('input', (e) => {
        // 排除 A、Q、R、G 鍵的直接輸入
        const excludedKeys = ['A', 'Q', 'R', 'G'];
        if (excludedKeys.includes(e.data) && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
          return;
        }
        handleTitleChange(node, titleInput);
      });

      // 添加keydown事件處理器來處理Enter鍵
      titleInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          titleInput.blur(); // 退出編輯狀態
          e.preventDefault();
        }

        // 阻止特定按鍵的默認行為
        const excludedKeys = ['a', 'q', 'r', 'g', 'A', 'Q', 'R', 'G'];
        if (excludedKeys.includes(e.key) && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
          e.stopPropagation();
        }
      });

      // 添加點擊事件處理，防止冒泡
      titleInput.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      const nodeData = findNodeByElement(node);
      if (nodeData) {
        updateJumpButton(nodeData);
      }
      return nodeData;
    }

    // 提取共用邏輯到獨立函數
    function handleTitleChange(node, titleInput) {
      const nodeData = findNodeByElement(node);

      const newTitle = titleInput.value.trim();

      // 排除特定按鍵觸發的無效變更
      const excludedKeys = ['A', 'Q', 'R', 'G'];
      if (excludedKeys.includes(newTitle)) {
        return;
      }
      if (nodeData) {
        nodeData.language = currentLanguage;

        // 檢查是否有相同名稱的節點已經有描述
        const sameNameNodes = nodes.filter(n =>
          n.id !== nodeData.id &&
          n.element.querySelector('.node-title').value === titleInput.value
        );

        if (sameNameNodes.length > 0 && !nodeDescriptions[nodeData.id]) {
          // 使用第一個同名節點的描述
          const firstSameNameNode = sameNameNodes[0];
          if (nodeDescriptions[firstSameNameNode.id]) {
            nodeDescriptions[nodeData.id] = nodeDescriptions[firstSameNameNode.id];
            updateNodeList(); // 觸發更新
          }
        }
        //nodeData.jumpIndex = 0;
        //updateJumpButton(nodeData);
        //updateSameNameHighlights();

      }

      //nodes.forEach(n => updateJumpButton(n));
    }



    function syncDescriptionsForSameNameNodes(nodeId) {
      const node = nodes[nodeId];
      if (!node) return;

      const title = node.element.querySelector('.node-title')?.value || '未命名節點';
      const description = nodeDescriptions[nodeId];

      if (description && description.trim() !== '') {
        // 更新所有同名節點的描述
        nodes.forEach(n => {
          if (n.id !== nodeId) {
            const nTitle = n.element.querySelector('.node-title')?.value || '未命名節點';
            if (nTitle === title) {
              nodeDescriptions[n.id] = description;
            }
          }
        });
      }
    }
    // 新增函數：更新所有同名節點的高亮狀態
    function updateSameNameHighlights() {
      // 先移除所有高亮
      document.querySelectorAll('.node').forEach(node => {
        node.classList.remove('highlight-same-name');
      });

      // 建立節點名稱映射
      const nameMap = {};
      nodes.forEach(node => {
        const title = node.element.querySelector('.node-title').value;
        if (!nameMap[title]) {
          nameMap[title] = [];
        }
        nameMap[title].push(node);
      });

      // 為有相同名稱的節點添加高亮
      Object.entries(nameMap).forEach(([title, sameNameNodes]) => {
        if (sameNameNodes.length > 1) {
          sameNameNodes.forEach(node => {
            node.element.classList.add('highlight-same-name');
          });
        }
      });
    }



    // 設置段落輸入
    function setupParagraphInput(node, nodeData) {
      const paragraphInput = node.querySelector('.paragraph-input');
      paragraphInput.addEventListener('input', function () {
        handleParagraphInput(this, node, nodeData);

        // 內容變化時自動分析變數
        if (this.value.trim()) {
          analyzeVariables(nodeData);
        }
      });
    }

    // 處理段落輸入
    function handleParagraphInput(inputElement, node, nodeData) {
      const content = inputElement.value.trim();
      if (content === '') return;

      // 根據當前語言提取函數名
      const functionName = extractFunctionName(content);
      if (functionName) {
        node.querySelector('.node-title').value = functionName;
      }

      // 根據當前語言提取被調用函數（現在會自動過濾 "(e"）
      const calledFunctions = extractCalledFunctions(content, functionName);
      if (calledFunctions.length > 0) {
        createFunctionItems(nodeData, calledFunctions, container);
      }

      setupParagraphPopup(inputElement, content, nodeData);

      // 根據當前語言分析變數
      analyzeVariables(nodeData);

      // 新增：確保清理任何可能殘留的 "(e" 項目
      setTimeout(() => {
        cleanupExistingItems(nodeData);
      }, 150);
    }

    // 設置初始添加按鈕
    function setupInitialAddButton(node, nodeData) {
      node.querySelector('.add-node-btn').addEventListener('click', (e) => {
        const itemElement = e.target.closest('.item');
        const itemText = itemElement ? itemElement.querySelector('.item-text').value : '';
        const functionName = itemText.trim();

        console.log(`初始添加按鈕點擊，函數名: "${functionName}"`);

        const childNodes = connections.filter(conn =>
          conn.fromNode === nodeData.id &&
          conn.fromOutput === 0
        ).length;

        const baseX = nodeData.x + 200 / scale;
        const baseY = nodeData.y + (childNodes * 120 / scale);

        // 從內存中的函數數據獲取對應的函數內容
        let functionContent = null;
        if (functionName && loadedHtmlFunctions[functionName]) {
          functionContent = loadedHtmlFunctions[functionName].code;
          console.log(`找到函數內容，長度: ${functionContent.length}`);
        }

        // 創建節點時使用準確的函數名和內容
        const newNode = createNode(
          baseX,
          baseY,
          functionName || '新節點',  // 只有空的時候才用默認名
          'normal',
          functionContent
        );

        if (functionContent) {
          showStatusMessage(`已自動填入函數 "${functionName}" 的內容`, 'success');
        } else if (functionName) {
          showStatusMessage(`創建節點 "${functionName}"，但未找到對應函數內容`, 'warning');
        }

        connections.push({
          fromNode: nodeData.id,
          fromOutput: 0,
          toNode: newNode.id
        });

        drawConnections();
        e.stopPropagation();
      });
    }
    // 設置添加項目按鈕
    function setupAddItemButton(node, nodeData) {
      node.querySelector('.add-item-btn').addEventListener('click', () => {
        addNewItem(node, nodeData);
      });
    }

    console.log('當前 setupGenerateButton 函數:', setupGenerateButton.toString());

    function setupGenerateButton(node, nodeData) {
      const generateBtn = node.querySelector('.generate-btn');
      if (!generateBtn) return;

      // 移除舊的事件監聽器
      const newGenerateBtn = generateBtn.cloneNode(true);
      generateBtn.parentNode.replaceChild(newGenerateBtn, generateBtn);

      newGenerateBtn.addEventListener('click', function (e) {
        console.log('=== 開始批量生成節點 ===');

        // 獲取所有項目
        const items = node.querySelectorAll('.item');
        console.log('找到項目數量:', items.length);

        if (items.length === 0) {
          showStatusMessage('沒有項目可生成', 'warning');
          return;
        }

        // 計算基礎位置
        const baseX = nodeData.x + 200 / scale;
        let baseY = nodeData.y;

        let successCount = 0;
        let failCount = 0;
        const failedNames = [];
        const createdNodes = []; // 保存創建的節點

        // 為每個項目創建子節點
        items.forEach((item, index) => {
          const itemText = item.querySelector('.item-text').value;
          const functionName = itemText.trim();

          console.log(`處理項目 ${index + 1}: "${functionName}"`);

          if (!functionName) {
            console.log(`跳過空項目 ${index + 1}`);
            return;
          }

          // 計算位置
          const col = Math.floor(index / 4);
          const row = index % 4;
          const currentX = baseX + (col * 250 / scale);
          const currentY = baseY + (row * 120 / scale);

          console.log(`位置計算: col=${col}, row=${row}, x=${currentX}, y=${currentY}`);

          // 查找函數內容
          let functionContent = null;
          let foundKey = functionName;

          // 1. 精確匹配
          if (loadedHtmlFunctions[functionName]) {
            functionContent = loadedHtmlFunctions[functionName].code;
            console.log(`✅ 精確匹配找到: "${functionName}"`);
          }
          // 2. 模糊匹配
          else {
            const lowerName = functionName.toLowerCase();
            for (const key in loadedHtmlFunctions) {
              if (key.toLowerCase() === lowerName) {
                functionContent = loadedHtmlFunctions[key].code;
                foundKey = key;
                console.log(`✅ 模糊匹配找到: "${key}" 對應 "${functionName}"`);
                break;
              }
            }
          }

          if (!functionContent) {
            console.log(`❌ 未找到函數內容: "${functionName}"`);
            failCount++;
            failedNames.push(functionName);
          } else {
            console.log(`✅ 找到函數內容，長度: ${functionContent.length}`);
            successCount++;
          }

          // 創建新節點
          const newNode = createNodeWithContent(
            currentX,
            currentY,
            functionName,
            functionContent
          );

          createdNodes.push(newNode); // 保存創建的節點

          // 添加連接
          connections.push({
            fromNode: nodeData.id,
            fromOutput: index,
            toNode: newNode.id
          });

          console.log(`創建節點完成: ${functionName}`);
        });

        // 確保所有節點都完成項目創建和轉換
        setTimeout(() => {
          let itemCreationCount = 0;
          createdNodes.forEach(newNode => {
            const itemsContainer = newNode.element.querySelector('.items');
            const itemsCount = itemsContainer.querySelectorAll('.item').length;
            if (itemsCount > 0) {
              itemCreationCount++;
            }
            console.log(`節點 "${newNode.element.querySelector('.node-title').value}" 有 ${itemsCount} 個項目`);
          });

          console.log(`✅ 完成 ${createdNodes.length} 個節點的創建`);
          console.log(`✅ ${itemCreationCount} 個節點成功創建了項目`);
        }, 800);

        // 重繪連接
        drawConnections();

        // 顯示結果
        let message = `批量生成完成: 創建 ${items.length} 個節點`;
        if (successCount > 0) {
          message += `, ${successCount} 個已填充內容、創建項目並轉換為按鈕`;
        }
        if (failCount > 0) {
          message += `, ${failCount} 個未找到內容`;
        }

        showStatusMessage(message, successCount > 0 ? 'success' : 'warning');

        console.log('批量生成總結:', {
          總項目數: items.length,
          成功填充: successCount,
          失敗: failCount,
          失敗列表: failedNames,
          創建節點數: createdNodes.length
        });

        e.stopPropagation();
      });
    }



    // 專門用於批量生成的節點創建函數
    function createNodeWithContent(x, y, title, content) {
      console.log(`創建帶內容的節點: "${title}", 內容=${content ? '有' : '無'}`);

      const node = createNodeElement(x, y, title);
      const nodeData = initializeNodeData(node, x, y);

      // 如果有內容，立即填充
      if (content) {
        const paragraphInput = node.querySelector('.paragraph-input');
        if (paragraphInput) {
          console.log(`正在填充內容到 "${title}"`);
          paragraphInput.value = content;

          // 立即觸發輸入事件來創建 item-text
          const inputEvent = new Event('input', { bubbles: true });
          paragraphInput.dispatchEvent(inputEvent);

          // 短暫延遲後自動轉換為按鈕並分析變數
          setTimeout(() => {
            // 分析函數內容並創建項目
            analyzeAndCreateItems(nodeData, content);
            // 轉換為按鈕
            convertToParagraphButton(nodeData);
            // 分析變數
            analyzeVariables(nodeData);
          }, 200);
        }
      }

      // 設置節點事件
      setupNodeDrag(node, nodeData);
      setupCollapseButton(node, nodeData);
      setupDeleteButton(node, nodeData);
      setupTitleInput(node);
      setupParagraphInput(node, nodeData);
      setupInitialAddButton(node, nodeData);
      setupAddItemButton(node, nodeData);
      setupHideChildrenButton(node, nodeData);
      setupGenerateButton(node, nodeData);
      setupPortEvents(node, nodeData);
      updateNodePosition(nodeData);
      setupVariableAnalysis(node, nodeData);

      return nodeData;
    }

    // 分析函數內容並自動創建 item-text 項目
    function analyzeAndCreateItems(nodeData, content) {
      console.log(`分析函數內容並創建項目: "${nodeData.element.querySelector('.node-title').value}"`);

      const functionName = extractFunctionName(content);
      const calledFunctions = extractCalledFunctions(content, functionName);

      console.log(`找到 ${calledFunctions.length} 個被調用函數:`, calledFunctions);

      if (calledFunctions.length > 0) {
        // 清空現有項目
        const itemsContainer = nodeData.element.querySelector('.items');
        itemsContainer.innerHTML = '';
        nodeData.outputs = [];

        // 為每個被調用函數創建項目
        calledFunctions.forEach((funcName, index) => {
          const newItem = document.createElement('div');
          newItem.className = 'item';
          newItem.innerHTML = `
        <span class="drag-handle">☰</span>
        <input type="text" class="item-text" value="${escapeHtml(funcName)}">
        <button class="add-node-btn">+</button>
        <div class="output-port" data-type="output" data-output-index="${index}"></div>
      `;
          itemsContainer.appendChild(newItem);

          nodeData.outputs.push(index);

          // 設置新項目的按鈕事件
          setupAddNodeButton(newItem, nodeData, index, container);
          setupOutputPort(newItem, nodeData, index, container);
          setupItemDragAndDrop(nodeData.element, nodeData);
        });

        console.log(`✅ 成功創建 ${calledFunctions.length} 個項目`);
      } else {
        console.log('⚠️ 未找到被調用函數，保持默認項目');
      }
    }



    // 自動將輸入框轉換為按鈕
    function convertToParagraphButton(nodeData) {
      const node = nodeData.element;
      const paragraphInput = node.querySelector('.paragraph-input');

      if (!paragraphInput || paragraphInput.style.display === 'none') {
        return; // 已經轉換過了或者沒有輸入框
      }

      const content = paragraphInput.value.trim();
      if (!content) {
        return; // 沒有內容不轉換
      }

      console.log(`自動轉換節點 "${node.querySelector('.node-title').value}" 為按鈕`);

      // 創建按鈕
      const btn = document.createElement('button');
      btn.className = 'paragraph-btn';
      btn.textContent = content.length > 50 ? content.substring(0, 47) + '...' : content;
      btn.dataset.originalContent = content;

      // 創建彈出框
      const popup = document.createElement('div');
      popup.className = 'paragraph-popup';
      popup.textContent = content;

      // 添加節點顏色類到彈出框
      const colorClass = getCurrentColorClass(nodeData);
      popup.classList.add(colorClass);

      // 創建容器
      const container = document.createElement('div');
      container.style.position = 'relative';
      container.style.display = 'inline-block';
      container.style.width = '100%';

      // 保存原始輸入框的引用
      const originalInput = paragraphInput.cloneNode(true);
      originalInput.style.display = 'none';
      container.appendChild(originalInput);
      container.appendChild(btn);
      container.appendChild(popup);

      // 替換輸入框
      paragraphInput.replaceWith(container);

      // 設置按鈕事件
      setupParagraphButtonEvents(btn, popup, originalInput, nodeData);

      console.log(`✅ 成功轉換節點為按鈕: "${node.querySelector('.node-title').value}"`);
    }




    // 重新綁定所有生成按鈕
    function rebindAllGenerateButtons() {
      nodes.forEach(nodeData => {
        if (!nodeData.isFrame && !nodeData.isGroupNode) {
          const generateBtn = nodeData.element.querySelector('.generate-btn');
          if (generateBtn) {
            setupGenerateButton(nodeData.element, nodeData);
          }
        }
      });
      console.log('已重新綁定所有生成按鈕');
    }

    // 在文件加載後調用
    setTimeout(rebindAllGenerateButtons, 3000);




    // 添加新項目
    // 修改 addNewItem 函數以包含拖動手柄
    function addNewItem(node, nodeData) {
      const itemsContainer = node.querySelector('.items');
      const itemCount = itemsContainer.children.length;

      const item = document.createElement('div');
      item.className = 'item';
      item.innerHTML = `
    <span class="drag-handle">☰</span>
    <input type="text" class="item-text" value="">
    <button class="add-node-btn">+</button>
    <div class="output-port" data-type="output" data-output-index="${itemCount}"></div>
  `;

      itemsContainer.appendChild(item);

      // 設置新項目的按鈕事件
      item.querySelector('.add-node-btn').addEventListener('click', (e) => {
        handleAddNodeClick(nodeData, itemCount, e);
      });

      // 設置新項目的拖動事件
      setupItemDragAndDrop(node, nodeData);

      // 更新節點數據
      nodeData.outputs.push(0);

      // 設置輸出埠事件
      setupOutputPort(item, nodeData, itemCount);

      return item;
    }

    // 處理添加節點點擊
    function handleAddNodeClick(nodeData, outputIndex, e) {
      const itemElement = e.target.closest('.item');
      const itemText = itemElement ? itemElement.querySelector('.item-text').value : '';
      const functionName = itemText.trim();

      console.log(`處理添加節點點擊，函數名: "${functionName}"`);

      const childNodes = connections.filter(conn =>
        conn.fromNode === nodeData.id &&
        conn.fromOutput === outputIndex
      ).length;

      const baseX = nodeData.x + 200 / scale;
      const baseY = nodeData.y + (childNodes * 120 / scale);

      // 從內存中的函數數據獲取對應的函數內容
      let functionContent = null;
      if (functionName && loadedHtmlFunctions[functionName]) {
        functionContent = loadedHtmlFunctions[functionName].code;
        console.log(`找到函數內容，長度: ${functionContent.length}`);
      }

      // 創建節點時使用準確的函數名和內容
      const newNode = createNode(
        baseX,
        baseY,
        functionName,  // 直接使用函數名
        'normal',
        functionContent
      );

      if (functionContent) {
        showStatusMessage(`已自動填入函數 "${functionName}" 的內容`, 'success');
      } else if (functionName) {
        showStatusMessage(`創建節點 "${functionName}"，但未找到對應函數內容`, 'warning');
      }

      connections.push({
        fromNode: nodeData.id,
        fromOutput: outputIndex,
        toNode: newNode.id
      });

      drawConnections();
      e.stopPropagation();
    }


    // 設置埠事件
    function setupPortEvents(node, nodeData) {
      // 輸入埠
      node.querySelector('.input-port').addEventListener('mouseup', (e) => {
        if (connecting) {
          connections.push({
            fromNode: connecting.fromNode,
            fromOutput: connecting.fromOutput,
            toNode: nodeData.id
          });
          connecting = null;
          container.classList.remove('connecting');
          drawConnections();
        }
      });

      // 初始輸出埠
      setupOutputPort(node.querySelector('.output-port'), nodeData, 0);
    }

    // 設置輸出埠
    function setupOutputPort(portElement, nodeData, outputIndex) {
      portElement.addEventListener('mousedown', (e) => {
        if (spacePressed || e.button === 1) return;

        // 獲取實際顯示的埠（可能是原始埠或header中的埠）
        const visiblePort = portElement.style.display !== 'none' ? portElement :
          nodeData.element.querySelector(`.header-port:nth-child(${outputIndex + 4})`);

        const rect = visiblePort.getBoundingClientRect();
        connecting = {
          startX: rect.left + rect.width / 2,
          startY: rect.top + rect.height / 2,
          fromNode: nodeData.id,
          fromOutput: outputIndex,
          currentX: rect.left + rect.width / 2,
          currentY: rect.top + rect.height / 2
        };
        container.classList.add('connecting');
        e.stopPropagation();
      });
    }

    // 修改節點位置更新函數
    function updateNodePosition(node) {
      node.element.style.left = `${node.x}px`;
      node.element.style.top = `${node.y}px`;
      node.element.style.transform = 'none'; // 確保節點不受容器縮放影響
    }


    // 更新彈出框的滾動位置
    function updatePopupScroll() {
      if (activePopup) {
        activePopup.scrollTop = popupScrollPosition;
      }
    }


    // 創建框選元素
    function createSelectionBox() {
      selectionBox = document.createElement('div');
      selectionBox.className = 'selection-box';
      selectionBox.style.display = 'none';
      document.body.appendChild(selectionBox);
      return selectionBox;
    }

    // 更新框選區域
    function updateSelectionBox(x1, y1, x2, y2) {
      const left = Math.min(x1, x2);
      const top = Math.min(y1, y2);
      const width = Math.abs(x2 - x1);
      const height = Math.abs(y2 - y1);

      selectionBox.style.left = `${left}px`;
      selectionBox.style.top = `${top}px`;
      selectionBox.style.width = `${width}px`;
      selectionBox.style.height = `${height}px`;
      selectionBox.style.display = 'block';
    }

    // 清除選擇
    function clearSelection() {
      // 先收集所有需要清除顏色的連接
      const connectionsToClear = [];

      selectedNodes.forEach(nodeId => {
        const node = nodes[nodeId];
        if (node && node.element) {
          node.element.classList.remove('selected');

          // 找出所有從該節點出發的連接
          connections.forEach(conn => {
            if (conn.fromNode === nodeId && conn.colorClass) {
              connectionsToClear.push(conn);
            }
          });
        }
      });

      // 清除這些連接的顏色標記
      connectionsToClear.forEach(conn => {
        delete conn.colorClass;
      });

      // 清空選擇集
      selectedNodes.clear();

      // 重繪連接線
      drawConnections();
    }

    // 檢查節點是否在選擇框內
    function isNodeInSelection(node, selectionRect) {
      // 如果是Frame-Node則直接返回false
      if (node.type === 'frame-node') {
        return false;
      }

      const nodeRect = node.element.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      // 將節點坐標轉換為相對於容器的坐標
      const nodeLeft = nodeRect.left - containerRect.left;
      const nodeRight = nodeRect.right - containerRect.left;
      const nodeTop = nodeRect.top - containerRect.top;
      const nodeBottom = nodeRect.bottom - containerRect.top;

      // 檢查節點是否在選擇框內
      return (
        nodeRight > selectionRect.left &&
        nodeLeft < selectionRect.right &&
        nodeBottom > selectionRect.top &&
        nodeTop < selectionRect.bottom
      );
    }

    // 選擇節點
    function selectNodesInBox(selectionRect, additiveSelection) {
      // 如果不是增減選擇模式，先清除選擇
      if (!additiveSelection) {
        clearSelection();
      }

      nodes.forEach(node => {
        // 檢查節點是否在選擇框內且不是Frame-Node
        if (isNodeInSelection(node, selectionRect)) {  // 這裡補上了右括號
          // 排除Frame-Node類型的節點
          if (node.type !== 'frame-node') {
            // 如果是增減選擇模式，切換選擇狀態
            if (additiveSelection) {
              if (selectedNodes.has(node.id)) {
                node.element.classList.remove('selected');
                selectedNodes.delete(node.id);
              } else {
                node.element.classList.add('selected');
                selectedNodes.add(node.id);
              }
            } else {
              // 普通模式，直接選擇
              node.element.classList.add('selected');
              selectedNodes.add(node.id);
            }
          }
        }
      });

      return selectedNodes.size > 0;
    }

    // 修改 selectNodeAndChildren 函數
    function selectNodeAndChildren(nodeId, excludeDuplicates = false) {
      const node = nodes[nodeId];
      if (!node) return;

      // 檢查是否要跳過此節點
      let shouldSkip = false;
      if (excludeDuplicates) {
        const jumpBtn = node.element.querySelector('.jump-to-btn');
        shouldSkip = jumpBtn && getComputedStyle(jumpBtn).display !== 'none';
      }

      if (!shouldSkip && !selectedNodes.has(nodeId)) {
        // 選取當前節點
        node.element.classList.add('selected');
        selectedNodes.add(nodeId);
      }

      // 無論是否跳過當前節點，都繼續處理子節點
      const children = connections.filter(conn => conn.fromNode === nodeId)
        .map(conn => conn.toNode);
      children.forEach(childId => {
        selectNodeAndChildren(childId, excludeDuplicates);
      });

      drawConnections();
    }
    function copySelectedNodesContent() {
      let allContent = '';

      selectedNodes.forEach(nodeId => {
        const node = nodes[nodeId];
        if (node) {
          const popup = node.element.querySelector('.paragraph-popup');
          const input = node.element.querySelector('.paragraph-input');

          if (popup) {
            allContent += popup.textContent + '\n\n';
          } else if (input) {
            allContent += input.value + '\n\n';
          }
        }
      });

      if (allContent) {
        const lineCount = allContent.split('\n').filter(line => line.trim() !== '').length;
        navigator.clipboard.writeText(allContent.trim())
          .then(() => {
            showStatusMessage(`已複製 ${selectedNodes.size} 個節點的內容 (共 ${lineCount} 行)`, 'success');
          })
          .catch(err => {
            console.error('複製失敗:', err);
            showStatusMessage('複製失敗', 'error');
          });
      } else {
        showStatusMessage('沒有可複製的內容', 'warning');
      }
    }


    // 初始化視圖位置
    translateX = window.innerWidth / 2 - 100;
    translateY = window.innerHeight / 2 - 50;
    nodesContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;

    // 初始化一個節點時使用世界坐標系
    //createNode(-100, -50); // 這會使節點出現在屏幕中心



    // 更新滑鼠事件處理
    container.addEventListener('mousedown', (e) => {
      if (e.button === 0 && !spacePressed && !draggingNode) { // 左鍵點擊
        const target = e.target;
        const clickedElement = target.closest('.node');
        const isFrame = clickedElement?.classList.contains('frame-node');

        // 獲取所有在點擊位置的節點（從上到下）
        const nodesAtPoint = getNodesAtPoint(e.clientX, e.clientY);

        if (!clickedElement) {
          // 開始框選（點擊空白處）
          isSelecting = true;
          container.classList.add('selecting');
          selectionStartX = e.clientX;
          selectionStartY = e.clientY;

          if (!selectionBox) {
            createSelectionBox();
          }
          updateSelectionBox(selectionStartX, selectionStartY, e.clientX, e.clientY);
          e.preventDefault();
        }
        else if (isFrame && !target.closest('.frame-header, .frame-footer, .resize-handle')) {
          // 點擊框架的非交互區域（允許事件穿透）
          const topNonFrameNode = nodesAtPoint.find(node => !node.classList.contains('frame-node'));
          if (topNonFrameNode) {
            handleNodeSelection(e, topNonFrameNode);
          } else {
            // 如果框架內沒有其他節點，則開始框選
            isSelecting = true;
            container.classList.add('selecting');
            selectionStartX = e.clientX;
            selectionStartY = e.clientY;

            if (!selectionBox) {
              createSelectionBox();
            }
            updateSelectionBox(selectionStartX, selectionStartY, e.clientX, e.clientY);
            e.preventDefault();
          }
        }
        else if (selectedNodes.size > 0) {
          // 如果已經有選中的節點，檢查點擊的是否是其中之一
          const clickedNode = findNodeByElement(clickedElement);
          if (clickedNode && selectedNodes.has(clickedNode.id)) {
            // 開始拖動所有選中的節點
            draggingNode = clickedNode;
            dragStartWorldX = toWorldX(e.clientX);
            dragStartWorldY = toWorldY(e.clientY);
            dragOffsetX = dragStartWorldX - clickedNode.x;
            dragOffsetY = dragStartWorldY - clickedNode.y;
          } else {
            clearSelection();
          }
        }
        else {
          // 普通節點點擊處理
          handleNodeSelection(e, clickedElement);
        }
      } else if (spacePressed || e.button === 1) { // 空格或中鍵
        isPanning = true;
        panStartX = e.clientX - translateX;
        panStartY = e.clientY - translateY;
        container.classList.add('panning');
        e.preventDefault();
      }
    });

    // 新增輔助函數：獲取點擊位置的所有節點（從上到下）
    function getNodesAtPoint(x, y) {
      return Array.from(document.querySelectorAll('.node'))
        .filter(node => {
          const rect = node.getBoundingClientRect();
          return x >= rect.left && x <= rect.right &&
            y >= rect.top && y <= rect.bottom;
        })
        .sort((a, b) => {
          // 按z-index排序，數值大的在前
          const zIndexA = parseInt(window.getComputedStyle(a).zIndex) || 0;
          const zIndexB = parseInt(window.getComputedStyle(b).zIndex) || 0;
          return zIndexB - zIndexA;
        });
    }

    // 新增輔助函數：處理節點選擇邏輯
    function handleNodeSelection(e, nodeElement) {
      const nodeData = findNodeByElement(nodeElement);
      if (!nodeData) return;

      // 如果是框架的頭部或調整手柄，則處理框架拖動
      if (nodeElement.classList.contains('frame-node') &&
        e.target.closest('.frame-header, .resize-handle')) {
        draggingNode = nodeData;
        dragStartWorldX = toWorldX(e.clientX);
        dragStartWorldY = toWorldY(e.clientY);
        dragOffsetX = dragStartWorldX - nodeData.x;
        dragOffsetY = dragStartWorldY - nodeData.y;
        e.stopPropagation();
        return;
      }

      // 普通節點處理
      if (!nodeElement.classList.contains('frame-node')) {
        // 清除現有選擇（除非按住Ctrl多選）
        if (!e.ctrlKey) {
          clearSelection();
        }

        // 添加當前節點到選擇集
        nodeElement.classList.add('selected');
        selectedNodes.add(nodeData.id);

        // 設置拖動
        draggingNode = nodeData;
        dragStartWorldX = toWorldX(e.clientX);
        dragStartWorldY = toWorldY(e.clientY);
        dragOffsetX = dragStartWorldX - nodeData.x;
        dragOffsetY = dragStartWorldY - nodeData.y;

        e.stopPropagation();
      }
    }

    document.addEventListener('mouseup', (e) => {
      if (draggingNode && draggingNode.isFrame) {
        delete draggingNode.containedNodes;
      }
      if (isSelecting) {
        const selectionRect = {
          left: Math.min(selectionStartX, e.clientX),
          right: Math.max(selectionStartX, e.clientX),
          top: Math.min(selectionStartY, e.clientY),
          bottom: Math.max(selectionStartY, e.clientY)
        };

        // 檢查是否有實際的選擇範圍（避免點擊誤觸發）
        if (selectionRect.right - selectionRect.left > 5 ||
          selectionRect.bottom - selectionRect.top > 5) {

          // 根據 SHIFT 鍵狀態決定是替換選擇還是增減選擇
          if (!shiftPressed) {
            clearSelection();
          }

          selectNodesInBox(selectionRect, shiftPressed);
        }

        isSelecting = false;
        container.classList.remove('selecting');
        if (selectionBox) {
          selectionBox.style.display = 'none';
        }
      }

      draggingNode = null;
      connecting = null;
      isPanning = false;
      container.classList.remove('panning');
      container.classList.remove('connecting');
      drawConnections();
    });

    // 替換mousemove事件中的拖拽部分
    document.addEventListener('mousemove', (e) => {
      if (isSelecting) {
        updateSelectionBox(selectionStartX, selectionStartY, e.clientX, e.clientY);
      } else if (isPanning) {
        translateX = e.clientX - panStartX;
        translateY = e.clientY - panStartY;
        applyTransform();
        drawConnections();
      } else if (draggingNode) {
        const currentWorldX = toWorldX(e.clientX);
        const currentWorldY = toWorldY(e.clientY);

        const deltaX = currentWorldX - dragStartWorldX;
        const deltaY = currentWorldY - dragStartWorldY;

        if (selectedNodes.size > 0) {
          // 移動所有選中的節點
          selectedNodes.forEach(id => {
            const node = nodes[id];
            if (node) {
              node.x += deltaX;
              node.y += deltaY;
              updateNodePosition(node);
            }
          });
        } else {
          // 移動單個節點
          draggingNode.x = currentWorldX - dragOffsetX;
          draggingNode.y = currentWorldY - dragOffsetY;
          updateNodePosition(draggingNode);
        }

        dragStartWorldX = currentWorldX;
        dragStartWorldY = currentWorldY;
        drawConnections();
      } else if (draggingNode) {
        const currentWorldX = toWorldX(e.clientX);
        const currentWorldY = toWorldY(e.clientY);

        const deltaX = currentWorldX - dragStartWorldX;
        const deltaY = currentWorldY - dragStartWorldY;

        if (selectedNodes.size > 0) {
          // ... existing selected nodes movement ...
        } else {
          // Move the dragging node (frame or regular node)
          draggingNode.x = currentWorldX - dragOffsetX;
          draggingNode.y = currentWorldY - dragOffsetY;
          updateNodePosition(draggingNode);

          // If it's a frame, move all contained nodes
          if (draggingNode.isFrame && draggingNode.containedNodes) {
            draggingNode.containedNodes.forEach(({ node, offsetX, offsetY }) => {
              node.x = draggingNode.x + offsetX;
              node.y = draggingNode.y + offsetY;
              updateNodePosition(node);
            });
          }
        }

        dragStartWorldX = currentWorldX;
        dragStartWorldY = currentWorldY;
        drawConnections();
      }

      else if (connecting) {
        connecting.currentX = e.clientX;
        connecting.currentY = e.clientY;
        drawConnections();
      }
    });


    function disconnectNodeFromParent(nodeId) {
      // 找出所有指向該節點的連接（父節點到該節點的連接）
      const parentConnections = connections.filter(conn => conn.toNode === nodeId);

      if (parentConnections.length === 0) {
        showStatusMessage('該節點沒有父節點連接', 'warning');
        return;
      }

      // 移除這些連接
      connections = connections.filter(conn => conn.toNode !== nodeId);

      // 重新繪製連接線
      drawConnections();

      showStatusMessage(`已斷開 ${parentConnections.length} 個父節點連接`, 'success');
    }


    // 選項1：在檔案頂部定義（推薦）
    const VERTICAL_SPACING = 10; // 全局常數

    function multiColumnAlignNodes() {
      if (!selectedNodes || selectedNodes.size < 2) return;

      const VERTICAL_SPACING = 10;    // 垂直間距
      const HORIZONTAL_SPACING = 30;  // 水平間距 (30px)

      // 1. 找出最左上角的節點作為排列基準點
      let baseNode = findTopLeftNode(selectedNodes, nodes);
      if (!baseNode) return;

      // 2. 將節點分組到各列
      const columns = groupNodesIntoColumns(baseNode, selectedNodes, nodes);

      // 3. 排列所有列（強制所有列第一個節點Y坐標對齊第一列）
      arrangeColumns(columns, baseNode, HORIZONTAL_SPACING, VERTICAL_SPACING, nodes);

      drawConnections();
      showStatusMessage(`已將 ${selectedNodes.size} 個節點進行多列排列`, 'success');
    }

    // 找出最左上角的節點（保持不變）
    function findTopLeftNode(selectedNodes, nodes) {
      let baseNode = null;
      let minX = Infinity;
      let minY = Infinity;

      selectedNodes.forEach(nodeId => {
        const node = nodes[nodeId];
        if (node.x < minX || (node.x === minX && node.y < minY)) {
          minX = node.x;
          minY = node.y;
          baseNode = node;
        }
      });

      return baseNode;
    }

    // 將節點分組到各列（保持不變）
    function groupNodesIntoColumns(baseNode, selectedNodes, nodes) {
      const columns = [[]];
      const otherNodes = Array.from(selectedNodes)
        .map(id => nodes[id])
        .filter(node => node !== baseNode);

      otherNodes.sort((a, b) => a.x - b.x);
      columns[0].push(baseNode);

      let currentCol = 0;
      otherNodes.forEach((node, index) => {
        const prevCol = columns[currentCol];
        const prevColRight = prevCol[0].x + prevCol[0].element.offsetWidth + 30;

        if (index > 0 && node.x > prevColRight) {
          currentCol++;
          columns[currentCol] = [];
        }
        columns[currentCol].push(node);
      });

      return columns;
    }

    // 排列所有列（關鍵修改）
    function arrangeColumns(columns, baseNode, hSpacing, vSpacing, nodes) {
      const baseY = baseNode.y;
      let prevColRight = baseNode.x + baseNode.element.offsetWidth;

      // 第一列保持原位
      arrangeSingleColumn(columns[0], baseY, vSpacing, baseNode.x, nodes);

      // 後續列對齊處理
      for (let i = 1; i < columns.length; i++) {
        const col = columns[i];
        const isNewGroup = (col[0].x - prevColRight) > hSpacing * 2; // 判斷是否為新群組

        const colX = isNewGroup
          ? prevColRight + hSpacing * 2 // 新群組加大間距
          : prevColRight + hSpacing;    // 原群組正常間距

        arrangeSingleColumn(col, baseY, vSpacing, colX, nodes);
        prevColRight = colX + getColumnWidth(col);
      }
    }

    // 其他輔助函數保持不變
    function getColumnWidth(columnNodes) {
      return Math.max(...columnNodes.map(node => node.element.offsetWidth));
    }

    function arrangeSingleColumn(columnNodes, startY, spacing, fixedX, nodes) {
      let currentY = startY;
      columnNodes.sort((a, b) => a.y - b.y);

      columnNodes.forEach(node => {
        node.x = fixedX;
        node.y = currentY;
        updateNodePosition(node);
        currentY += node.element.offsetHeight + spacing;
      });
    }

    // 鍵盤控制
    document.addEventListener('keydown', (e) => {
      // 檢查是否正在輸入框中輸入內容
      const isInputting = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable;

      if (e.key === 'Delete' && selectedNodes.size > 0) {
        e.preventDefault();
        deleteSelectedNodes();
      }



      if (e.key.toLowerCase() === 'g' && selectedNodes.size > 1) {
        createGroupNodeFromSelection();
        e.preventDefault();
      }
      // 處理 'z' 鍵：切換選中節點的顏色
      if (e.key.toLowerCase() === 'z' && selectedNodes.size > 0 && !isInputting) {
        toggleNodeColors();
        e.preventDefault();
      }

      // 處理 'c' 鍵：將選中節點對齊到最右側節點的X坐標
      if (e.key.toLowerCase() === 'c' && selectedNodes.size > 1 && !isInputting) {
        multiColumnAlignNodes();  // 替換為新的多列排列函數
        e.preventDefault();
      }
      if (e.key.toLowerCase() === 'v' && selectedNodes.size > 1 && !isInputting) {
        collapseAndAlignSelectedNodes();
        arrangeSelectedNodesVertically();
        e.preventDefault();
      }

      if (e.key === 'b' || e.key === 'B') {
        if (selectedNodes.size > 0) {
          arrangeSelectedNodesBalanced();
        }
      }
      // 處理 'd' 鍵：斷開選中節點與父節點的連接
      if (e.key.toLowerCase() === 'd' && selectedNodes.size === 1 && !isInputting) {
        const nodeId = selectedNodes.values().next().value;
        disconnectNodeFromParent(nodeId);
        e.preventDefault();
      }

      // 處理 'q' 鍵：複製選中節點內容
      if (e.key.toLowerCase() === 'q' && selectedNodes.size > 0) {
        copySelectedNodesContent();
        e.preventDefault();
      }

      // 處理 'space' 鍵：設置抓取光標
      if (e.code === 'Space') {
        spacePressed = true;
        container.style.cursor = 'grab';
      }

      // 處理 'shift' 鍵：設置 shiftPressed 狀態
      if (e.key === 'Shift') {
        shiftPressed = true;
      }


      if (e.key.toLowerCase() === 'r' && selectedNodes.size === 1) {
        const selectedNodeId = Array.from(selectedNodes)[0];
        colorizeChildConnections(selectedNodeId);
        drawConnections();
      }

      // 處理 'a' 鍵：選取子節點
      if (e.key.toLowerCase() === 'a' && selectedNodes.size === 1) {
        const firstSelectedId = selectedNodes.values().next().value;
        const prevSelected = new Set(selectedNodes); // 保存當前已選取節點

        const excludeDuplicates = document.getElementById('exclude-duplicates-checkbox').checked;
        selectNodeAndChildren(firstSelectedId, excludeDuplicates);

        // 計算新增選取的節點數量
        let addedCount = 0;
        selectedNodes.forEach(id => {
          if (!prevSelected.has(id)) addedCount++;
        });

        showStatusMessage(`已選取 ${addedCount} 個子節點`, 'success');
        e.preventDefault();

      }

      // 處理 'e' 鍵：在視圖中心創建節點
      if (e.key.toLowerCase() === 'e' && !isInputting) {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const worldX = toWorldX(centerX);
        const worldY = toWorldY(centerY);
        createNode(worldX, worldY);
        e.preventDefault();
      }

      // 處理彈出框滾動
      if (!activePopup) return;

      const scrollStep = 20; // 每次滾動的像素數
      switch (e.key.toLowerCase()) {
        case 'w':
          popupScrollPosition = Math.max(0, popupScrollPosition - scrollStep);
          updatePopupScroll();
          e.preventDefault();
          break;
        case 's':
          const maxScroll = activePopup.scrollHeight - activePopup.clientHeight;
          popupScrollPosition = Math.min(maxScroll, popupScrollPosition + scrollStep);
          updatePopupScroll();
          e.preventDefault();
          break;
      }
    });


    // 平衡排列選中節點的函數（最多子節點在中間，最少在兩端）
    function arrangeSelectedNodesBalanced() {
      if (selectedNodes.size === 0) {
        showStatusMessage('請先選擇要排列的節點', 'warning');
        return;
      }

      console.log('開始平衡排列選中的節點...');

      // 1. 獲取選中的節點
      const selectedNodeIds = Array.from(selectedNodes);
      const selectedNodesArray = selectedNodeIds.map(id => nodes[id]);

      // 2. 按子節點數量排序
      const sortedNodes = sortNodesByChildCountBalanced(selectedNodesArray);

      // 3. 找到排列的起始位置（保持原有的X位置）
      const baseX = findMostCommonXPosition(selectedNodesArray);
      const startY = findTopmostYPosition(selectedNodesArray);

      // 4. 平衡排列節點（只改變Y位置）
      arrangeNodesInBalancedPattern(sortedNodes, baseX, startY);

      drawConnections();
      showStatusMessage(`已平衡排列 ${selectedNodes.size} 個節點（最多子節點在中間）`, 'success');
    }

    // 按子節點數量進行平衡排序
    function sortNodesByChildCountBalanced(nodeArray) {
      // 先按子節點數量排序（從少到多）
      const sortedByCount = nodeArray.sort((a, b) => {
        const aChildCount = getChildNodeCount(a.id);
        const bChildCount = getChildNodeCount(b.id);
        return aChildCount - bChildCount;
      });

      // 然後重新排列：最少子節點的節點在兩端，最多子節點的節點在中間
      const balancedArray = [];
      const length = sortedByCount.length;

      for (let i = 0; i < length; i++) {
        if (i % 2 === 0) {
          // 偶數索引：從前面取（較少子節點）
          balancedArray.push(sortedByCount.shift());
        } else {
          // 奇數索引：從後面取（較多子節點）
          balancedArray.push(sortedByCount.pop());
        }
      }

      return balancedArray;
    }

    // 按照平衡模式排列節點
    function arrangeNodesInBalancedPattern(nodeArray, baseX, startY) {
      const verticalSpacing = 50; // 節點間的垂直間距

      if (nodeArray.length === 0) return;

      nodeArray.forEach((node, index) => {
        // 只改變Y位置，保持原有的X位置
        const yPos = startY + (index * verticalSpacing);

        node.y = yPos;
        // X位置保持不變，使用節點原有的x坐標
        updateNodePosition(node);
      });

      // 顯示排列信息
      showBalancedArrangementInfo(nodeArray);
    }


    // 找到最常見的X位置（用於參考，但實際保持各節點原有X位置）
    function findMostCommonXPosition(nodeArray) {
      if (nodeArray.length === 0) return 0;

      // 簡單返回第一個節點的X位置作為參考
      return nodeArray[0].x;
    }

    // 顯示平衡排列的詳細信息
    function showBalancedArrangementInfo(nodeArray) {
      const arrangementInfo = nodeArray.map((node, index) => {
        const title = node.element.querySelector('.node-title').value;
        const childCount = getChildNodeCount(node.id);
        const position = index === 0 ? '頂部' :
          index === nodeArray.length - 1 ? '底部' :
            index === Math.floor(nodeArray.length / 2) ? '中間' : '其他';

        return { title, childCount, position };
      });

      console.log('平衡排列詳情:', arrangementInfo);

      // 統計信息
      const topNode = arrangementInfo[0];
      const bottomNode = arrangementInfo[arrangementInfo.length - 1];
      const middleIndex = Math.floor(arrangementInfo.length / 2);
      const middleNode = arrangementInfo[middleIndex];

      let infoMessage = `排列完成：`;
      infoMessage += `頂部「${topNode.title}」(${topNode.childCount}子節點) | `;
      infoMessage += `中間「${middleNode.title}」(${middleNode.childCount}子節點) | `;
      infoMessage += `底部「${bottomNode.title}」(${bottomNode.childCount}子節點)`;

      showStatusMessage(infoMessage, 'info');
    }


    // 刪除選中節點的函數
    function deleteSelectedNodes() {
      const nodesToDelete = Array.from(selectedNodes).map(id => nodes.find(n => n && n.id === id)).filter(Boolean);

      nodesToDelete.forEach(node => {
        if (!node) return;

        // 1. 刪除所有與該節點相關的連接
        connections = connections.filter(conn =>
          conn.fromNode !== node.id && conn.toNode !== node.id
        );

        // 2. 從DOM中移除節點元素
        if (node.element && node.element.parentNode) {
          node.element.remove();
        }

        // 3. 移除彈出框容器
        if (node.popupContainer) {
          node.popupContainer.remove();
        }

        // 4. 從全局彈出框集合中移除
        const popup = node.element?.querySelector('.paragraph-popup');
        if (popup) {
          ALL_ACTIVE_POPUPS.delete(popup);
        }

        // 5. 從節點數組中移除
        const index = nodes.findIndex(n => n && n.id === node.id);
        if (index !== -1) {
          nodes.splice(index, 1);
        }
      });

      // 重新分配節點ID
      reassignNodeIds();

      // 清除選中狀態
      selectedNodes.clear();

      // 更新顯示
      drawConnections();
      updateNodeList();

      showStatusMessage(`已刪除 ${nodesToDelete.length} 個節點`, 'success');
    }

    // 重新分配節點ID以保持連續性
    function reassignNodeIds() {
      nodes.forEach((node, index) => {
        if (node) {
          const oldId = node.id;
          node.id = index;

          // 更新連接中的節點ID
          connections.forEach(conn => {
            if (conn.fromNode === oldId) conn.fromNode = index;
            if (conn.toNode === oldId) conn.toNode = index;
          });

          // 更新選中節點集合中的ID
          if (selectedNodes.has(oldId)) {
            selectedNodes.delete(oldId);
            selectedNodes.add(index);
          }
        }
      });
    }


    // 折疊並對齊選中的節點
    function collapseAndAlignSelectedNodes() {
      if (selectedNodes.size < 2) return;

      // 獲取選中的節點，並過濾掉顯示 jump-to-btn 的節點
      const selectedNodesArray = Array.from(selectedNodes)
        .map(id => nodes[id])
        .filter(node => {
          if (!node || node.isFrame) return false;

          // 檢查節點是否顯示 jump-to-btn
          const jumpBtn = node.element.querySelector('.jump-to-btn');
          const isJumpBtnVisible = jumpBtn && !jumpBtn.classList.contains('hidden');

          // 如果顯示 jump-to-btn，則過濾掉這個節點
          return !isJumpBtnVisible;
        });

      if (selectedNodesArray.length < 2) return;

      // 1. 首先折疊所有選中的節點
      selectedNodesArray.forEach(node => {
        collapseNode(node);
      });

      // 2. 使用原有的多列對齊函數
      multiColumnAlignNodes();

      showStatusMessage(`已折疊並對齊 ${selectedNodesArray.length} 個節點`, 'success');
    }
    // 折疊單個節點
    function collapseNode(node) {
      const nodeElement = node.element;
      const collapseBtn = nodeElement.querySelector('.collapse-btn');

      if (collapseBtn && !nodeElement.classList.contains('collapsed')) {
        // 觸發折疊
        nodeElement.classList.add('collapsed');

        const collapsible = nodeElement.querySelector('.collapsible');
        const originalPorts = nodeElement.querySelectorAll('.output-port:not(.header-port)');
        const headerPort = nodeElement.querySelector('.header-port');

        // 隱藏原始埠，顯示頭部埠
        originalPorts.forEach(port => port.style.display = 'none');
        if (!headerPort) {
          const port = document.createElement('div');
          port.className = 'output-port header-port';
          port.dataset.type = 'output';
          port.style.display = 'block';
          nodeElement.querySelector('.node-header').appendChild(port);
        } else {
          headerPort.style.display = 'block';
        }

        collapseBtn.textContent = '+';

        // 重繪連接
        drawConnections();
      }
    }


    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        spacePressed = false;
        if (!isPanning) {
          container.style.cursor = '';
        }
      } else if (e.key === 'Shift') {
        shiftPressed = false;
      }
    });
    // 點擊空白處取消選擇
    container.addEventListener('click', (e) => {
      if (e.target === container && selectedNodes.size > 0) {
        clearSelection();
      }
    });

    // 輔助函數：通過元素查找節點
    function findNodeByElement(element) {
      return nodes.find(node => node.element === element);
    }

    // 滾輪縮放
    container.addEventListener('wheel', (e) => {
      e.preventDefault();

      // 獲取鼠標位置相對於視口的坐標
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      // 計算縮放前的世界坐標
      const worldX = (mouseX - translateX) / scale;
      const worldY = (mouseY - translateY) / scale;

      // 計算新的縮放比例（保持原有方向邏輯）
      const delta = -e.deltaY;
      const newScale = delta > 0 ? scale * 1.1 : scale / 1.1;
      scale = Math.min(Math.max(0.1, newScale), 3);

      // 計算新的平移值 - 保持鼠標下的點在相同位置
      translateX = mouseX - worldX * scale;
      translateY = mouseY - worldY * scale;

      // 應用變換
      applyTransform();
    });

    function applyTransform() {
      console.log('Applying transform:', {
        translateX,
        translateY,
        scale,
        screenCenterX: (window.innerWidth / 2 - translateX) / scale,
        screenCenterY: (window.innerHeight / 2 - translateY) / scale
      });

      transformContainer.style.transform = `
    translate(${translateX}px, ${translateY}px)
    scale(${scale})
  `;
      nodesContainer.style.transform = `
    translate(${translateX}px, ${translateY}px)
    scale(${scale})
  `;
      drawConnections();
      updateNodeList();

      updateMinimap();
    }

    function drawConnections() {
      return new Promise((resolve) => {
        console.log("Current connections:", JSON.parse(JSON.stringify(connections)));
        console.log("Current node outputs:", nodes.map(n => ({
          id: n.id,
          outputs: n.outputs,
          ports: Array.from(n.element.querySelectorAll('.output-port')).map(p => ({
            outputIndex: p.dataset.outputIndex,
            originalIndex: p.dataset.originalIndex
          }))
        })));

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // 定義15種半透明顏色
        // 先繪製非折疊節點的連接
        connections.forEach(conn => {
          const fromNode = nodes[conn.fromNode];
          const toNode = nodes[conn.toNode];

          let fromPort;
          if (fromNode.element.classList.contains('collapsed')) {
            fromPort = fromNode.element.querySelector('.header-port');
          } else {
            fromPort = fromNode.element.querySelectorAll('.output-port:not(.header-port)')[conn.fromOutput];
          }

          const toPort = toNode.element.querySelector('.input-port');
          if (!fromPort || !toPort) return;

          const fromRect = fromPort.getBoundingClientRect();
          const toRect = toPort.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();

          const startX = fromRect.left + fromRect.width / 2 - containerRect.left;
          const startY = fromRect.top + fromRect.height / 2 - containerRect.top;
          const endX = toRect.left + toRect.width / 2 - containerRect.left;
          const endY = toRect.top + toRect.height / 2 - containerRect.top;

          ctx.beginPath();
          ctx.moveTo(startX, startY);

          if (fromNode.element.classList.contains('collapsed')) {
            const controlOffset = 100 + (conn.fromOutput * 15);
            ctx.bezierCurveTo(
              startX + controlOffset, startY,
              endX - 100, endY,
              endX, endY
            );
          } else {
            ctx.bezierCurveTo(
              startX + 100, startY,
              endX - 100, endY,
              endX, endY
            );
          }

          // 設置連接線顏色（優先級：高亮 > 顏色類 > 默認）
          if (conn.highlighted) {
            ctx.strokeStyle = '#4a90e2';
            ctx.lineWidth = 3;
          } else if (conn.colorClass) {
            // 使用顏色類對應的鮮豔顏色
            const colorNum = parseInt(conn.colorClass.split('-')[1]);
            ctx.strokeStyle = CONNECTION_COLORS[colorNum % CONNECTION_COLORS.length];
            ctx.lineWidth = 2;
          } else {
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
          }

          ctx.stroke();
        });

        // 繪製正在連接中的線條（保持原樣）
        if (connecting) {
          const fromNode = nodes[connecting.fromNode];
          let fromPort;
          if (fromNode.element.classList.contains('collapsed')) {
            fromPort = fromNode.element.querySelector(`.header-port[data-output-index="${connecting.fromOutput}"]`);
          } else {
            fromPort = fromNode.element.querySelectorAll('.output-port:not(.header-port)')[connecting.fromOutput];
          }

          if (!fromPort) return;

          const fromRect = fromPort.getBoundingClientRect();
          const startX = fromRect.left + fromRect.width / 2 - container.getBoundingClientRect().left;
          const startY = fromRect.top + fromRect.height / 2 - container.getBoundingClientRect().top;
          const endX = connecting.currentX - container.getBoundingClientRect().left;
          const endY = connecting.currentY - container.getBoundingClientRect().top;

          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 2 * (1 / scale);
          ctx.stroke();
        }

        // 確保所有繪圖操作完成後再 resolve
        // 使用 requestAnimationFrame 確保瀏覽器完成渲染
        requestAnimationFrame(() => {
          resolve();
        });
      });
    }


    function startAutoProcessing() {
      // 將節點數量限制定義為參數
      const NODE_LIMIT = 50; // 修改為50

      // 清除之前的處理
      stopAutoProcessing();

      // 檢查節點數量
      if (generatedNodeCount >= NODE_LIMIT) {
        showStatusMessage(`已達到節點數量限制 (${generatedNodeCount}/${NODE_LIMIT}個)，停止自動處理`, 'warning');
        return;
      }

      autoProcessingStartTime = Date.now();
      processedNodes.clear();
      processingQueue = [];
      currentPhase = 'initial';

      showStatusMessage(`開始自動處理缺失節點 (當前完整節點: ${generatedNodeCount}/${NODE_LIMIT})`, 'info');

      // 開始處理循環
      autoProcessingInterval = setInterval(() => {
        // 每次處理前檢查節點數量
        if (generatedNodeCount >= NODE_LIMIT) {
          showStatusMessage(`已達到節點數量限制 (${generatedNodeCount}/${NODE_LIMIT}個)，自動終止`, 'success');
          stopAutoProcessing();
          return;
        }
        processAutoWorkflow();
      }, 800);

      // 設置超時保護
      setTimeout(() => {
        if (autoProcessingInterval) {
          stopAutoProcessing();
          showStatusMessage('自動處理已超時終止', 'warning');
        }
      }, 240000);
    }

    // 新增函數：檢查節點是否已完成自動填入
    function isNodeCompleted(node) {
      // 檢查是否已完成 paragraph-input 自動填入
      const paragraphInput = node.element.querySelector('.paragraph-input');
      const hasParagraphContent = paragraphInput && paragraphInput.value.trim() !== '';

      // 檢查是否已完成 item-text 自動填入
      const itemTexts = node.element.querySelectorAll('.item-text');
      let hasItemContent = false;

      if (itemTexts.length > 0) {
        itemTexts.forEach(item => {
          if (item.value.trim() !== '') {
            hasItemContent = true;
          }
        });
      } else {
        // 如果沒有 item-text 元素，則認為這部分已完成
        hasItemContent = true;
      }

      return hasParagraphContent && hasItemContent;
    }



    // 停止自動處理
    function stopAutoProcessing() {
      if (autoProcessingInterval) {
        clearInterval(autoProcessingInterval);
        autoProcessingInterval = null;
      }
      processedNodes.clear();
      processingQueue = [];
      currentPhase = 'completed';
    }

    // 自動處理工作流程
    function processAutoWorkflow() {
      // 檢查是否超時
      if (Date.now() - autoProcessingStartTime > 30000) {
        stopAutoProcessing();
        showStatusMessage('自動處理已超時終止', 'warning');
        return;
      }

      // 檢查節點數量限制
      if (generatedNodeCount >= 50) {
        showStatusMessage(`已達到節點數量限制 (${generatedNodeCount}/50)，停止所有自動化步驟`, 'warning');
        stopAutoProcessing();
        return;
      }

      // 根據當前階段執行不同的處理
      switch (currentPhase) {
        case 'initial':
          processInitialPhase();
          break;
        case 'collapse_non_highlighted':
          processCollapseNonHighlighted();
          break;
        case 'arrange_non_highlighted':
          processArrangeNonHighlighted();
          break;
        case 'expand_highlighted':
          processExpandHighlighted();
          break;
        case 'arrange_highlighted':
          processArrangeHighlighted();
          break;
        case 'process_missing_items':
          processMissingItems();
          break;
        case 'check_completion':
          checkCompletion();
          break;
        case 'completed':
          stopAutoProcessing();
          showStatusMessage('自動處理完成！', 'success');
          break;
      }
    }



    // 階段1: 初始檢查
    function processInitialPhase() {
      showStatusMessage('階段1: 初始檢查缺失節點...', 'info');

      // 重新檢查缺失節點
      const hadMissingNodes = missingNodeNames.size > 0;
      checkMissingNodes();

      if (missingNodeNames.size === 0) {
        currentPhase = 'completed';
        return;
      }

      currentPhase = 'collapse_non_highlighted';
    }

    // 階段2: 折疊沒有紅框的節點
    function processCollapseNonHighlighted() {
      showStatusMessage('階段2: 折疊沒有紅框的節點...', 'info');

      let hasWork = false;

      nodes.forEach(node => {
        if (!node.element.classList.contains('highlight-missing') &&
          !node.element.classList.contains('collapsed') &&
          !processedNodes.has(`collapse_${node.id}`)) {

          const collapseBtn = node.element.querySelector('.collapse-btn');
          if (collapseBtn) {
            // 確保節點是展開狀態才進行折疊
            if (collapseBtn.textContent === '-') {
              collapseBtn.click();
              processedNodes.add(`collapse_${node.id}`);
              hasWork = true;
            }
          }
        }
      });

      if (!hasWork) {
        currentPhase = 'arrange_non_highlighted';
      }
    }

    // 階段3: 排列沒有紅框的節點到父節點右側
    function processArrangeNonHighlighted() {
      showStatusMessage('階段3: 排列沒有紅框的節點...', 'info');

      // 收集所有沒有紅框的節點
      const nonHighlightedNodes = nodes.filter(node =>
        !node.element.classList.contains('highlight-missing')
      );

      if (nonHighlightedNodes.length > 0) {
        // 暫時選中這些節點
        const previousSelection = new Set(selectedNodes);
        clearSelection();

        nonHighlightedNodes.forEach(node => {
          selectedNodes.add(node.id);
          node.element.classList.add('selected');
        });

        // 執行多列排列
        multiColumnAlignNodes();

        // 恢復之前的選擇狀態
        clearSelection();
        previousSelection.forEach(id => {
          selectedNodes.add(id);
          if (nodes[id]) {
            nodes[id].element.classList.add('selected');
          }
        });
      }

      currentPhase = 'expand_highlighted';
    }

    // 階段4: 展開有紅框的節點
    function processExpandHighlighted() {
      showStatusMessage('階段4: 展開有紅框的節點...', 'info');

      let hasWork = false;

      nodes.forEach(node => {
        if (node.element.classList.contains('highlight-missing') &&
          node.element.classList.contains('collapsed') &&
          !processedNodes.has(`expand_${node.id}`)) {

          const collapseBtn = node.element.querySelector('.collapse-btn');
          if (collapseBtn && collapseBtn.textContent === '+') {
            collapseBtn.click();
            processedNodes.add(`expand_${node.id}`);
            hasWork = true;
          }
        }
      });

      if (!hasWork) {
        currentPhase = 'arrange_highlighted';
      }
    }

    // 階段5: 排列有紅框的節點到排列組的右側
    function processArrangeHighlighted() {
      showStatusMessage('階段5: 排列有紅框的節點...', 'info');

      const highlightedNodes = nodes.filter(node =>
        node.element.classList.contains('highlight-missing')
      );

      if (highlightedNodes.length > 0) {
        // 找到排列組的最右側位置
        let maxRight = -Infinity;
        nodes.forEach(node => {
          if (!node.element.classList.contains('highlight-missing')) {
            const nodeRight = node.x + node.element.offsetWidth;
            maxRight = Math.max(maxRight, nodeRight);
          }
        });

        // 如果沒有非紅框節點，從左側開始
        if (maxRight === -Infinity) {
          maxRight = 50; // 從左側50px開始
        }

        // 排列紅框節點到右側
        const startX = maxRight + 100; // 右側間距100px
        let currentY = 50; // 從頂部50px開始

        highlightedNodes.forEach(node => {
          node.x = startX;
          node.y = currentY;
          updateNodePosition(node);
          currentY += node.element.offsetHeight + 20; // 垂直間距20px
        });

        drawConnections();
      }

      currentPhase = 'process_missing_items';
    }

    // 階段6: 處理缺失的item-text
    function processMissingItems() {
      showStatusMessage('階段6: 處理缺失項目...', 'info');

      let hasWork = false;

      nodes.forEach(node => {
        const missingItems = node.element.querySelectorAll('.item.highlight-missing');
        missingItems.forEach(item => {
          const itemId = `item_${node.id}_${Array.from(item.parentNode.children).indexOf(item)}`;

          if (!processedNodes.has(itemId)) {
            const addButton = item.querySelector('.add-node-btn');
            const itemText = item.querySelector('.item-text');
            const functionName = itemText ? itemText.value.trim() : '';

            if (addButton && functionName && !isInBlacklist(functionName)) {
              // 檢查節點數量限制
              if (generatedNodeCount >= 50) {
                showStatusMessage(`已達到節點數量限制 (${generatedNodeCount}/50)，停止創建新節點`, 'warning');
                stopAutoProcessing();
                return;
              }

              showStatusMessage(`自動創建節點: ${functionName} (${generatedNodeCount}/50)`, 'info');

              // 模擬點擊添加節點按鈕
              addButton.click();
              processedNodes.add(itemId);
              hasWork = true;

              // 自動載入函數內容到新創建的節點
              setTimeout(() => {
                autoLoadFunctionContentToLatestNode(functionName);
              }, 300);
            }
          }
        });
      });

      if (!hasWork) {
        currentPhase = 'check_completion';
      }
    }

    // 階段7: 檢查完成狀態
    function checkCompletion() {
      showStatusMessage('階段7: 檢查完成狀態...', 'info');

      // 檢查節點數量限制
      if (generatedNodeCount >= 50) {
        showStatusMessage(`已達到節點數量限制 (${generatedNodeCount}/50)，停止處理`, 'warning');
        currentPhase = 'completed';
        stopAutoProcessing();
        return;
      }

      // 重新檢查缺失節點
      const previousMissingCount = missingNodeNames.size;
      checkMissingNodes();

      if (missingNodeNames.size === 0) {
        // 沒有缺失節點了，完成處理
        currentPhase = 'completed';
        showStatusMessage('所有缺失節點已處理完成！', 'success');

        // 自動執行2次重新排列，忽略任何錯誤
        executeDoubleRearrangement();
      } else if (missingNodeNames.size === previousMissingCount) {
        // 缺失節點數量沒有變化，可能出現死循環，強制終止
        showStatusMessage('檢測到可能死循環，強制終止處理', 'warning');
        currentPhase = 'completed';

        // 即使有死循環，也嘗試執行重新排列
        executeDoubleRearrangement();
      } else {
        // 還有缺失節點，重新開始處理流程
        processedNodes.clear(); // 清除處理記錄，重新開始
        currentPhase = 'collapse_non_highlighted';
        showStatusMessage(`還有 ${missingNodeNames.size} 個缺失節點，繼續處理... (當前完整節點: ${generatedNodeCount}/50)`, 'info');
      }
    }

    // 新增函數：執行雙重重新排列
    async function executeDoubleRearrangement() {
      showStatusMessage('開始執行最終排列優化...', 'info');

      try {
        // 第一次重新排列
        await safeExecuteRearrangement(1);

        // 等待短暫時間確保第一次排列完成
        await new Promise(resolve => setTimeout(resolve, 500));

        // 第二次重新排列
        await safeExecuteRearrangement(2);

        showStatusMessage('最終排列優化完成！', 'success');
      } catch (error) {
        console.warn('雙重重新排列過程中發生錯誤，但流程繼續:', error);
        showStatusMessage('排列優化完成（部分操作有警告）', 'warning');
      }
    }

    // 新增函數：安全執行重新排列
    async function safeExecuteRearrangement(attempt) {
      return new Promise(async (resolve) => {
        try {
          console.log(`開始第${attempt}次重新排列...`);
          showStatusMessage(`執行第${attempt}次節點排列...`, 'info');

          await rearrangeAllNodesEnhanced();

          console.log(`第${attempt}次重新排列完成`);
          resolve();
        } catch (error) {
          console.warn(`第${attempt}次重新排列發生錯誤，但繼續執行:`, error);
          // 即使出錯也要 resolve，讓流程繼續
          resolve();
        }
      });
    }


    // 自動載入函數內容到最新創建的節點
    function autoLoadFunctionContentToLatestNode(functionName) {
      // 找到最新創建的節點（最後一個節點）
      if (nodes.length > 0) {
        const latestNode = nodes[nodes.length - 1];
        const titleElement = latestNode.element.querySelector('.node-title');

        // 檢查節點名稱是否匹配
        if (titleElement && (titleElement.value.includes(functionName) || titleElement.value === functionName + ' 節點')) {
          const success = autoLoadFunctionContent(latestNode, functionName);

          if (success) {
            // 檢查節點是否已完成自動填入
            if (isNodeCompleted(latestNode)) {
              generatedNodeCount++;
              showStatusMessage(`節點創建完成！當前完整節點數量: ${generatedNodeCount}/50`, 'success');

              // 檢查是否達到限制
              if (generatedNodeCount >= 50) {
                showStatusMessage(`已達到節點數量限制 (${generatedNodeCount}/50)，停止所有自動化步驟`, 'warning');
                stopAutoProcessing();
              }
            }
          }
        }
      }
    }



    // 自動載入函數內容（修改現有函數）
    function autoLoadFunctionContent(node, functionName) {
      // 從 localStorage 獲取已載入的 HTML 函數
      const loadedFunctions = JSON.parse(localStorage.getItem('loadedHtmlFunctions') || '{}');

      if (loadedFunctions[functionName]) {
        // 自動填入函數內容到節點
        const paragraphInput = node.element.querySelector('.paragraph-input');
        if (paragraphInput) {
          paragraphInput.value = loadedFunctions[functionName].code || loadedFunctions[functionName];

          // 觸發輸入事件以處理內容
          const inputEvent = new Event('input', { bubbles: true });
          paragraphInput.dispatchEvent(inputEvent);

          showStatusMessage(`已自動填入函數 "${functionName}" 的內容`, 'success');
          return true;
        }
      } else {
        // 如果沒有找到對應的函數內容，也認為節點已完成（可能沒有 paragraph-input）
        showStatusMessage(`未找到函數 "${functionName}" 的內容，但節點創建完成`, 'info');
        return true;
      }
      return false;
    }


    // 確保這個函數存在且正確工作
    function autoLoadFunctionContent(node, functionName) {
      // 從 localStorage 獲取已載入的 HTML 函數
      const loadedFunctions = JSON.parse(localStorage.getItem('loadedHtmlFunctions') || '{}');

      if (loadedFunctions[functionName]) {
        // 自動填入函數內容到節點
        const paragraphInput = node.element.querySelector('.paragraph-input');
        if (paragraphInput) {
          paragraphInput.value = loadedFunctions[functionName].code || loadedFunctions[functionName];

          // 觸發輸入事件以處理內容
          const inputEvent = new Event('input', { bubbles: true });
          paragraphInput.dispatchEvent(inputEvent);

          showStatusMessage(`已自動填入函數 "${functionName}" 的內容`, 'success');
          return true;
        }
      }
      return false;
    }

    function initAutoProcessing() {
      const stopBtn = document.createElement('button');
      stopBtn.className = 'toolbar-btn';
      stopBtn.id = 'stop-auto-process-btn';
      stopBtn.textContent = '停止自動處理';
      stopBtn.style.display = 'none';
      stopBtn.addEventListener('click', () => {
        stopAutoProcessing();
        showStatusMessage('手動停止自動處理', 'info');
      });

      const toolbar = document.getElementById('toolbar');
      if (toolbar) {
        toolbar.appendChild(stopBtn);
      }

      // 在自動處理開始/結束時顯示/隱藏停止按鈕
      const originalStart = startAutoProcessing;
      startAutoProcessing = function () {
        stopBtn.style.display = 'inline-block';
        return originalStart.apply(this, arguments);
      };

      const originalStop = stopAutoProcessing;
      stopAutoProcessing = function () {
        stopBtn.style.display = 'none';
        return originalStop.apply(this, arguments);
      };
    }

    // 修改初始化代碼
    function init() {
      // 設置canvas大小
      canvas.width = container.offsetWidth;
      canvas.height = container.offsetHeight;

      // 初始化位置和縮放
      scale = 1;
      translateX = container.offsetWidth / 2 - 100;
      translateY = container.offsetHeight / 2 - 50;

      applyTransform();

      // 創建初始節點
      createNode(-100, -50);
      // 初始高亮檢查
      updateSameNameHighlights();

      // 初始化左側面板
      updateNodeList();


      // 設置定期檢查可見節點的定時器
      setInterval(checkVisibleNodes, 500);
      initMinimap();
      initAutoProcessing();
    }

    // 檢查可見節點並更新列表
    function checkVisibleNodes() {
      const visibleNodes = getVisibleNodes();
      if (JSON.stringify(visibleNodes) !== JSON.stringify(lastVisibleNodes)) {
        updateNodeList();
        lastVisibleNodes = visibleNodes;
      }
    }

    // 獲取當前可見的節點（修正座標版本）
    function getVisibleNodes() {
      // 1. 獲取視口可見區域（不考慮左側面板，使用整個視窗）
      const viewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: window.innerHeight
      };

      return nodes.filter(node => {
        // 2. 直接使用getBoundingClientRect獲取屏幕座標
        const rect = node.element.getBoundingClientRect();

        // 3. 檢查節點是否在視口內（完全精確判斷）
        const isVisible = (
          rect.right > viewport.left &&
          rect.left < viewport.right &&
          rect.bottom > viewport.top &&
          rect.top < viewport.bottom
        );

        // 4. 控制名稱顯示（直接基於屏幕座標判斷）
        const nameElement = node.element.querySelector('.node-name');
        if (nameElement) {
          nameElement.style.display = isVisible ? 'block' : 'none';
        }

        // 5. 返回節點是否在緩衝區內（用於渲染優化）
        const buffer = -200; // 屏幕像素緩衝
        const inBufferArea = (
          rect.right > (viewport.left - buffer) &&
          rect.left < (viewport.right + buffer) &&
          rect.bottom > (viewport.top - buffer) &&
          rect.top < (viewport.bottom + buffer)
        );

        return inBufferArea;
      });
    }

    // 輔助函數：獲取節點高度
    function getNodeHeight(nodeElement) {
      // 簡單估算節點高度（可根據實際需求調整）
      const titleHeight = 30;
      const paragraphHeight = nodeElement.querySelector('.paragraph-input') ? 70 : 0;
      const itemsHeight = nodeElement.querySelectorAll('.item').length * 30;
      const buttonsHeight = 30;

      return titleHeight + paragraphHeight + itemsHeight + buttonsHeight + 20; // 20px padding
    }

    // 更新節點列表 - 優化版本
    function updateNodeList() {
      const nodeList = document.getElementById('node-list');
      if (!nodeList) return;

      requestAnimationFrame(() => {
        saveCurrentDescriptions();
        const visibleNodes = getVisibleNodes();
        const visibleNodeIds = visibleNodes.map(n => n.id).join(',');
        const lastVisibleNodeIds = (lastVisibleNodes || []).map(n => n.id).join(',');

        if (visibleNodeIds === lastVisibleNodeIds) return;



        // 建立節點名稱到描述的映射
        const nameToDescriptionMap = {};
        nodes.forEach(node => {
          const title = node.element.querySelector('.node-title')?.value || '未命名節點';
          if (nodeDescriptions[node.id] && nodeDescriptions[node.id].trim() !== '') {
            // 如果這個節點有描述，記錄到映射中
            nameToDescriptionMap[title] = nodeDescriptions[node.id];
          }
        });

        const fragment = document.createDocumentFragment();

        visibleNodes.forEach(node => {
          const nodeElement = document.createElement('div');
          nodeElement.className = 'node-list-item';

          const title = node.element.querySelector('.node-title')?.value || '未命名節點';

          // 檢查是否有相同名稱的節點已經有描述
          let description = nodeDescriptions[node.id] || '';
          if (!description.trim() && nameToDescriptionMap[title]) {
            // 如果當前節點沒有描述，但相同名稱的節點有描述，則使用該描述
            description = nameToDescriptionMap[title];
            nodeDescriptions[node.id] = description; // 更新節點描述資料
          }

          nodeElement.innerHTML = `
        <div class="node-list-name">${escapeHtml(title)}</div>
        <textarea class="node-list-description" data-node-id="${node.id}" 
          placeholder="輸入節點描述...">${escapeHtml(description)}</textarea>
      `;

          const descInput = nodeElement.querySelector('.node-list-description');
          descInput.addEventListener('input', () => {
            const newDescription = descInput.value;
            nodeDescriptions[descInput.dataset.nodeId] = newDescription;
            // 新增：立即保存變更
            saveCurrentDescriptions();
            // 當描述變更時，更新所有同名節點的描述
            if (newDescription.trim() !== '') {
              const currentTitle = node.element.querySelector('.node-title')?.value || '未命名節點';
              nodes.forEach(n => {
                const nTitle = n.element.querySelector('.node-title')?.value || '未命名節點';
                if (nTitle === currentTitle && n.id !== node.id) {
                  nodeDescriptions[n.id] = newDescription;
                }
              });
              syncDescriptionsForSameNameNodes(descInput.dataset.nodeId);
              // 觸發重新渲染節點列表
              updateNodeList();
            }
          });

          fragment.appendChild(nodeElement);
        });

        nodeList.innerHTML = '';
        nodeList.appendChild(fragment);
        lastVisibleNodes = visibleNodes;
      });

      console.log('Current descriptions:', nodeDescriptions);

    }

    // 優化的檢查函數
    function checkVisibleNodes() {
      // 使用防抖技術減少頻繁檢查
      if (!this.checkVisibleNodesDebounce) {
        this.checkVisibleNodesDebounce = debounce(() => {
          updateNodeList();
        }, 100);
      }
      this.checkVisibleNodesDebounce();
    }

    // 簡單的防抖函數
    function debounce(func, wait) {
      let timeout;
      return function () {
        const context = this, args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          func.apply(context, args);
        }, wait);
      };
    }

    // 保存當前描述
    function saveCurrentDescriptions() {
      document.querySelectorAll('.node-list-description').forEach(input => {
        nodeDescriptions[input.dataset.nodeId] = input.value;
      });
      // 同時保存到專案數據和 localStorage
      localStorage.setItem('nodeDescriptions', JSON.stringify(nodeDescriptions));
    }

    // 初始化
    init();

    // 初始化視圖位置
    translateX = window.innerWidth / 2 - 100;
    translateY = window.innerHeight / 2 - 50;
    nodesContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;




    // 初始化一個節點
    //createNode(0, 0);
  </script>
</body>

</html>